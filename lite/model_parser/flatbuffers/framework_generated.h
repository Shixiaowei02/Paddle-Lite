// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FRAMEWORK_PADDLE_LITE_FBS_H_
#define FLATBUFFERS_GENERATED_FRAMEWORK_PADDLE_LITE_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace paddle {
namespace lite {
namespace fbs {

struct Version;
struct VersionBuilder;

struct OpDesc;
struct OpDescBuilder;

namespace OpDesc_ {

struct Attr;
struct AttrBuilder;

struct Var;
struct VarBuilder;

}  // namespace OpDesc_

struct VarType;
struct VarTypeBuilder;

namespace VarType_ {

struct TensorDesc;
struct TensorDescBuilder;

struct LoDTensorDesc;
struct LoDTensorDescBuilder;

struct LoDTensorArrayDesc;
struct LoDTensorArrayDescBuilder;

struct ReaderDesc;
struct ReaderDescBuilder;

struct Tuple;
struct TupleBuilder;

}  // namespace VarType_

struct VarDesc;
struct VarDescBuilder;

struct BlockDesc;
struct BlockDescBuilder;

struct CompatibleInfo;
struct CompatibleInfoBuilder;

struct OpCompatibleMap;
struct OpCompatibleMapBuilder;

namespace OpCompatibleMap_ {

struct OpCompatiblePair;
struct OpCompatiblePairBuilder;

}  // namespace OpCompatibleMap_

struct ProgramDesc;
struct ProgramDescBuilder;

enum AttrType {
  AttrType_INT = 0,
  AttrType_FLOAT = 1,
  AttrType_STRING = 2,
  AttrType_INTS = 3,
  AttrType_FLOATS = 4,
  AttrType_STRINGS = 5,
  AttrType_BOOLEAN = 6,
  AttrType_BOOLEANS = 7,
  AttrType_BLOCK = 8,
  AttrType_LONG = 9,
  AttrType_BLOCKS = 10,
  AttrType_LONGS = 11,
  AttrType_MIN = AttrType_INT,
  AttrType_MAX = AttrType_LONGS
};

inline const AttrType (&EnumValuesAttrType())[12] {
  static const AttrType values[] = {
    AttrType_INT,
    AttrType_FLOAT,
    AttrType_STRING,
    AttrType_INTS,
    AttrType_FLOATS,
    AttrType_STRINGS,
    AttrType_BOOLEAN,
    AttrType_BOOLEANS,
    AttrType_BLOCK,
    AttrType_LONG,
    AttrType_BLOCKS,
    AttrType_LONGS
  };
  return values;
}

inline const char * const *EnumNamesAttrType() {
  static const char * const names[13] = {
    "INT",
    "FLOAT",
    "STRING",
    "INTS",
    "FLOATS",
    "STRINGS",
    "BOOLEAN",
    "BOOLEANS",
    "BLOCK",
    "LONG",
    "BLOCKS",
    "LONGS",
    nullptr
  };
  return names;
}

inline const char *EnumNameAttrType(AttrType e) {
  if (flatbuffers::IsOutRange(e, AttrType_INT, AttrType_LONGS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAttrType()[index];
}

namespace VarType_ {

enum Type {
  Type_BOOL = 0,
  Type_INT16 = 1,
  Type_INT32 = 2,
  Type_INT64 = 3,
  Type_FP16 = 4,
  Type_FP32 = 5,
  Type_FP64 = 6,
  Type_LOD_TENSOR = 7,
  Type_SELECTED_ROWS = 8,
  Type_FEED_MINIBATCH = 9,
  Type_FETCH_LIST = 10,
  Type_STEP_SCOPES = 11,
  Type_LOD_RANK_TABLE = 12,
  Type_LOD_TENSOR_ARRAY = 13,
  Type_PLACE_LIST = 14,
  Type_READER = 15,
  Type_RAW = 17,
  Type_TUPLE = 18,
  Type_SIZE_T = 19,
  Type_UINT8 = 20,
  Type_INT8 = 21,
  Type_MIN = Type_BOOL,
  Type_MAX = Type_INT8
};

inline const Type (&EnumValuesType())[21] {
  static const Type values[] = {
    Type_BOOL,
    Type_INT16,
    Type_INT32,
    Type_INT64,
    Type_FP16,
    Type_FP32,
    Type_FP64,
    Type_LOD_TENSOR,
    Type_SELECTED_ROWS,
    Type_FEED_MINIBATCH,
    Type_FETCH_LIST,
    Type_STEP_SCOPES,
    Type_LOD_RANK_TABLE,
    Type_LOD_TENSOR_ARRAY,
    Type_PLACE_LIST,
    Type_READER,
    Type_RAW,
    Type_TUPLE,
    Type_SIZE_T,
    Type_UINT8,
    Type_INT8
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[23] = {
    "BOOL",
    "INT16",
    "INT32",
    "INT64",
    "FP16",
    "FP32",
    "FP64",
    "LOD_TENSOR",
    "SELECTED_ROWS",
    "FEED_MINIBATCH",
    "FETCH_LIST",
    "STEP_SCOPES",
    "LOD_RANK_TABLE",
    "LOD_TENSOR_ARRAY",
    "PLACE_LIST",
    "READER",
    "",
    "RAW",
    "TUPLE",
    "SIZE_T",
    "UINT8",
    "INT8",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (flatbuffers::IsOutRange(e, Type_BOOL, Type_INT8)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

}  // namespace VarType_

namespace CompatibleInfo_ {

enum Type {
  Type_COMPATIBLE = 0,
  Type_DEFINITELY_NOT = 1,
  Type_POSSIBLE = 2,
  Type_BUG_FIX = 3,
  Type_PRECISION_CHANGE = 4,
  Type_MIN = Type_COMPATIBLE,
  Type_MAX = Type_PRECISION_CHANGE
};

inline const Type (&EnumValuesType())[5] {
  static const Type values[] = {
    Type_COMPATIBLE,
    Type_DEFINITELY_NOT,
    Type_POSSIBLE,
    Type_BUG_FIX,
    Type_PRECISION_CHANGE
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[6] = {
    "COMPATIBLE",
    "DEFINITELY_NOT",
    "POSSIBLE",
    "BUG_FIX",
    "PRECISION_CHANGE",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (flatbuffers::IsOutRange(e, Type_COMPATIBLE, Type_PRECISION_CHANGE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

}  // namespace CompatibleInfo_

struct Version FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VersionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4
  };
  int64_t version() const {
    return GetField<int64_t>(VT_VERSION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VERSION) &&
           verifier.EndTable();
  }
};

struct VersionBuilder {
  typedef Version Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(int64_t version) {
    fbb_.AddElement<int64_t>(Version::VT_VERSION, version, 0);
  }
  explicit VersionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Version> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Version>(end);
    return o;
  }
};

inline flatbuffers::Offset<Version> CreateVersion(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t version = 0) {
  VersionBuilder builder_(_fbb);
  builder_.add_version(version);
  return builder_.Finish();
}

struct OpDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_ATTRS = 10,
    VT_IS_TARGET = 12
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc_::Var>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc_::Var>> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc_::Var>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc_::Var>> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc_::Attr>> *attrs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc_::Attr>> *>(VT_ATTRS);
  }
  bool is_target() const {
    return GetField<uint8_t>(VT_IS_TARGET, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           VerifyOffset(verifier, VT_ATTRS) &&
           verifier.VerifyVector(attrs()) &&
           verifier.VerifyVectorOfTables(attrs()) &&
           VerifyField<uint8_t>(verifier, VT_IS_TARGET) &&
           verifier.EndTable();
  }
};

struct OpDescBuilder {
  typedef OpDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(OpDesc::VT_TYPE, type);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc_::Var>>> inputs) {
    fbb_.AddOffset(OpDesc::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc_::Var>>> outputs) {
    fbb_.AddOffset(OpDesc::VT_OUTPUTS, outputs);
  }
  void add_attrs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc_::Attr>>> attrs) {
    fbb_.AddOffset(OpDesc::VT_ATTRS, attrs);
  }
  void add_is_target(bool is_target) {
    fbb_.AddElement<uint8_t>(OpDesc::VT_IS_TARGET, static_cast<uint8_t>(is_target), 0);
  }
  explicit OpDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OpDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpDesc>(end);
    fbb_.Required(o, OpDesc::VT_TYPE);
    return o;
  }
};

inline flatbuffers::Offset<OpDesc> CreateOpDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc_::Var>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc_::Var>>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc_::Attr>>> attrs = 0,
    bool is_target = false) {
  OpDescBuilder builder_(_fbb);
  builder_.add_attrs(attrs);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_type(type);
  builder_.add_is_target(is_target);
  return builder_.Finish();
}

inline flatbuffers::Offset<OpDesc> CreateOpDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    std::vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc_::Var>> *inputs = nullptr,
    std::vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc_::Var>> *outputs = nullptr,
    std::vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc_::Attr>> *attrs = nullptr,
    bool is_target = false) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVectorOfSortedTables<paddle::lite::fbs::OpDesc_::Var>(inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVectorOfSortedTables<paddle::lite::fbs::OpDesc_::Var>(outputs) : 0;
  auto attrs__ = attrs ? _fbb.CreateVectorOfSortedTables<paddle::lite::fbs::OpDesc_::Attr>(attrs) : 0;
  return paddle::lite::fbs::CreateOpDesc(
      _fbb,
      type__,
      inputs__,
      outputs__,
      attrs__,
      is_target);
}

namespace OpDesc_ {

struct Attr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttrBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_I = 8,
    VT_F = 10,
    VT_S = 12,
    VT_INTS = 14,
    VT_FLOATS = 16,
    VT_STRINGS = 18,
    VT_B = 20,
    VT_BOOLS = 22,
    VT_BLOCK_IDX = 24,
    VT_L = 26,
    VT_BLOCKS_IDX = 28,
    VT_LONGS = 30
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const Attr *o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(name()->c_str(), val);
  }
  paddle::lite::fbs::AttrType type() const {
    return static_cast<paddle::lite::fbs::AttrType>(GetField<int32_t>(VT_TYPE, 0));
  }
  int32_t i() const {
    return GetField<int32_t>(VT_I, 0);
  }
  float f() const {
    return GetField<float>(VT_F, 0.0f);
  }
  const flatbuffers::String *s() const {
    return GetPointer<const flatbuffers::String *>(VT_S);
  }
  const flatbuffers::Vector<int32_t> *ints() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INTS);
  }
  const flatbuffers::Vector<float> *floats() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_FLOATS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *strings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_STRINGS);
  }
  bool b() const {
    return GetField<uint8_t>(VT_B, 0) != 0;
  }
  const flatbuffers::Vector<uint8_t> *bools() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BOOLS);
  }
  int32_t block_idx() const {
    return GetField<int32_t>(VT_BLOCK_IDX, 0);
  }
  int64_t l() const {
    return GetField<int64_t>(VT_L, 0);
  }
  const flatbuffers::Vector<int32_t> *blocks_idx() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCKS_IDX);
  }
  const flatbuffers::Vector<int64_t> *longs() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_LONGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_I) &&
           VerifyField<float>(verifier, VT_F) &&
           VerifyOffset(verifier, VT_S) &&
           verifier.VerifyString(s()) &&
           VerifyOffset(verifier, VT_INTS) &&
           verifier.VerifyVector(ints()) &&
           VerifyOffset(verifier, VT_FLOATS) &&
           verifier.VerifyVector(floats()) &&
           VerifyOffset(verifier, VT_STRINGS) &&
           verifier.VerifyVector(strings()) &&
           verifier.VerifyVectorOfStrings(strings()) &&
           VerifyField<uint8_t>(verifier, VT_B) &&
           VerifyOffset(verifier, VT_BOOLS) &&
           verifier.VerifyVector(bools()) &&
           VerifyField<int32_t>(verifier, VT_BLOCK_IDX) &&
           VerifyField<int64_t>(verifier, VT_L) &&
           VerifyOffset(verifier, VT_BLOCKS_IDX) &&
           verifier.VerifyVector(blocks_idx()) &&
           VerifyOffset(verifier, VT_LONGS) &&
           verifier.VerifyVector(longs()) &&
           verifier.EndTable();
  }
};

struct AttrBuilder {
  typedef Attr Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Attr::VT_NAME, name);
  }
  void add_type(paddle::lite::fbs::AttrType type) {
    fbb_.AddElement<int32_t>(Attr::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_i(int32_t i) {
    fbb_.AddElement<int32_t>(Attr::VT_I, i, 0);
  }
  void add_f(float f) {
    fbb_.AddElement<float>(Attr::VT_F, f, 0.0f);
  }
  void add_s(flatbuffers::Offset<flatbuffers::String> s) {
    fbb_.AddOffset(Attr::VT_S, s);
  }
  void add_ints(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ints) {
    fbb_.AddOffset(Attr::VT_INTS, ints);
  }
  void add_floats(flatbuffers::Offset<flatbuffers::Vector<float>> floats) {
    fbb_.AddOffset(Attr::VT_FLOATS, floats);
  }
  void add_strings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> strings) {
    fbb_.AddOffset(Attr::VT_STRINGS, strings);
  }
  void add_b(bool b) {
    fbb_.AddElement<uint8_t>(Attr::VT_B, static_cast<uint8_t>(b), 0);
  }
  void add_bools(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bools) {
    fbb_.AddOffset(Attr::VT_BOOLS, bools);
  }
  void add_block_idx(int32_t block_idx) {
    fbb_.AddElement<int32_t>(Attr::VT_BLOCK_IDX, block_idx, 0);
  }
  void add_l(int64_t l) {
    fbb_.AddElement<int64_t>(Attr::VT_L, l, 0);
  }
  void add_blocks_idx(flatbuffers::Offset<flatbuffers::Vector<int32_t>> blocks_idx) {
    fbb_.AddOffset(Attr::VT_BLOCKS_IDX, blocks_idx);
  }
  void add_longs(flatbuffers::Offset<flatbuffers::Vector<int64_t>> longs) {
    fbb_.AddOffset(Attr::VT_LONGS, longs);
  }
  explicit AttrBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Attr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Attr>(end);
    fbb_.Required(o, Attr::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Attr> CreateAttr(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    paddle::lite::fbs::AttrType type = paddle::lite::fbs::AttrType_INT,
    int32_t i = 0,
    float f = 0.0f,
    flatbuffers::Offset<flatbuffers::String> s = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ints = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> floats = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> strings = 0,
    bool b = false,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bools = 0,
    int32_t block_idx = 0,
    int64_t l = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> blocks_idx = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> longs = 0) {
  AttrBuilder builder_(_fbb);
  builder_.add_l(l);
  builder_.add_longs(longs);
  builder_.add_blocks_idx(blocks_idx);
  builder_.add_block_idx(block_idx);
  builder_.add_bools(bools);
  builder_.add_strings(strings);
  builder_.add_floats(floats);
  builder_.add_ints(ints);
  builder_.add_s(s);
  builder_.add_f(f);
  builder_.add_i(i);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_b(b);
  return builder_.Finish();
}

inline flatbuffers::Offset<Attr> CreateAttrDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    paddle::lite::fbs::AttrType type = paddle::lite::fbs::AttrType_INT,
    int32_t i = 0,
    float f = 0.0f,
    const char *s = nullptr,
    const std::vector<int32_t> *ints = nullptr,
    const std::vector<float> *floats = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *strings = nullptr,
    bool b = false,
    const std::vector<uint8_t> *bools = nullptr,
    int32_t block_idx = 0,
    int64_t l = 0,
    const std::vector<int32_t> *blocks_idx = nullptr,
    const std::vector<int64_t> *longs = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto s__ = s ? _fbb.CreateString(s) : 0;
  auto ints__ = ints ? _fbb.CreateVector<int32_t>(*ints) : 0;
  auto floats__ = floats ? _fbb.CreateVector<float>(*floats) : 0;
  auto strings__ = strings ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*strings) : 0;
  auto bools__ = bools ? _fbb.CreateVector<uint8_t>(*bools) : 0;
  auto blocks_idx__ = blocks_idx ? _fbb.CreateVector<int32_t>(*blocks_idx) : 0;
  auto longs__ = longs ? _fbb.CreateVector<int64_t>(*longs) : 0;
  return paddle::lite::fbs::OpDesc_::CreateAttr(
      _fbb,
      name__,
      type,
      i,
      f,
      s__,
      ints__,
      floats__,
      strings__,
      b,
      bools__,
      block_idx,
      l,
      blocks_idx__,
      longs__);
}

struct Var FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VarBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETER = 4,
    VT_ARGUMENTS = 6
  };
  const flatbuffers::String *parameter() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAMETER);
  }
  bool KeyCompareLessThan(const Var *o) const {
    return *parameter() < *o->parameter();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(parameter()->c_str(), val);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ARGUMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PARAMETER) &&
           verifier.VerifyString(parameter()) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfStrings(arguments()) &&
           verifier.EndTable();
  }
};

struct VarBuilder {
  typedef Var Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_parameter(flatbuffers::Offset<flatbuffers::String> parameter) {
    fbb_.AddOffset(Var::VT_PARAMETER, parameter);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> arguments) {
    fbb_.AddOffset(Var::VT_ARGUMENTS, arguments);
  }
  explicit VarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Var> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Var>(end);
    fbb_.Required(o, Var::VT_PARAMETER);
    return o;
  }
};

inline flatbuffers::Offset<Var> CreateVar(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> parameter = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> arguments = 0) {
  VarBuilder builder_(_fbb);
  builder_.add_arguments(arguments);
  builder_.add_parameter(parameter);
  return builder_.Finish();
}

inline flatbuffers::Offset<Var> CreateVarDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *parameter = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *arguments = nullptr) {
  auto parameter__ = parameter ? _fbb.CreateString(parameter) : 0;
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*arguments) : 0;
  return paddle::lite::fbs::OpDesc_::CreateVar(
      _fbb,
      parameter__,
      arguments__);
}

}  // namespace OpDesc_

struct VarType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VarTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_SELECTED_ROWS = 6,
    VT_LOD_TENSOR = 8,
    VT_TENSOR_ARRAY = 10,
    VT_READER = 12,
    VT_TUPLE = 14
  };
  paddle::lite::fbs::VarType_::Type type() const {
    return static_cast<paddle::lite::fbs::VarType_::Type>(GetField<int32_t>(VT_TYPE, 0));
  }
  const paddle::lite::fbs::VarType_::TensorDesc *selected_rows() const {
    return GetPointer<const paddle::lite::fbs::VarType_::TensorDesc *>(VT_SELECTED_ROWS);
  }
  const paddle::lite::fbs::VarType_::LoDTensorDesc *lod_tensor() const {
    return GetPointer<const paddle::lite::fbs::VarType_::LoDTensorDesc *>(VT_LOD_TENSOR);
  }
  const paddle::lite::fbs::VarType_::LoDTensorArrayDesc *tensor_array() const {
    return GetPointer<const paddle::lite::fbs::VarType_::LoDTensorArrayDesc *>(VT_TENSOR_ARRAY);
  }
  const paddle::lite::fbs::VarType_::ReaderDesc *reader() const {
    return GetPointer<const paddle::lite::fbs::VarType_::ReaderDesc *>(VT_READER);
  }
  const paddle::lite::fbs::VarType_::Tuple *tuple() const {
    return GetPointer<const paddle::lite::fbs::VarType_::Tuple *>(VT_TUPLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_SELECTED_ROWS) &&
           verifier.VerifyTable(selected_rows()) &&
           VerifyOffset(verifier, VT_LOD_TENSOR) &&
           verifier.VerifyTable(lod_tensor()) &&
           VerifyOffset(verifier, VT_TENSOR_ARRAY) &&
           verifier.VerifyTable(tensor_array()) &&
           VerifyOffset(verifier, VT_READER) &&
           verifier.VerifyTable(reader()) &&
           VerifyOffset(verifier, VT_TUPLE) &&
           verifier.VerifyTable(tuple()) &&
           verifier.EndTable();
  }
};

struct VarTypeBuilder {
  typedef VarType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(paddle::lite::fbs::VarType_::Type type) {
    fbb_.AddElement<int32_t>(VarType::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_selected_rows(flatbuffers::Offset<paddle::lite::fbs::VarType_::TensorDesc> selected_rows) {
    fbb_.AddOffset(VarType::VT_SELECTED_ROWS, selected_rows);
  }
  void add_lod_tensor(flatbuffers::Offset<paddle::lite::fbs::VarType_::LoDTensorDesc> lod_tensor) {
    fbb_.AddOffset(VarType::VT_LOD_TENSOR, lod_tensor);
  }
  void add_tensor_array(flatbuffers::Offset<paddle::lite::fbs::VarType_::LoDTensorArrayDesc> tensor_array) {
    fbb_.AddOffset(VarType::VT_TENSOR_ARRAY, tensor_array);
  }
  void add_reader(flatbuffers::Offset<paddle::lite::fbs::VarType_::ReaderDesc> reader) {
    fbb_.AddOffset(VarType::VT_READER, reader);
  }
  void add_tuple(flatbuffers::Offset<paddle::lite::fbs::VarType_::Tuple> tuple) {
    fbb_.AddOffset(VarType::VT_TUPLE, tuple);
  }
  explicit VarTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VarType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VarType>(end);
    return o;
  }
};

inline flatbuffers::Offset<VarType> CreateVarType(
    flatbuffers::FlatBufferBuilder &_fbb,
    paddle::lite::fbs::VarType_::Type type = paddle::lite::fbs::VarType_::Type_BOOL,
    flatbuffers::Offset<paddle::lite::fbs::VarType_::TensorDesc> selected_rows = 0,
    flatbuffers::Offset<paddle::lite::fbs::VarType_::LoDTensorDesc> lod_tensor = 0,
    flatbuffers::Offset<paddle::lite::fbs::VarType_::LoDTensorArrayDesc> tensor_array = 0,
    flatbuffers::Offset<paddle::lite::fbs::VarType_::ReaderDesc> reader = 0,
    flatbuffers::Offset<paddle::lite::fbs::VarType_::Tuple> tuple = 0) {
  VarTypeBuilder builder_(_fbb);
  builder_.add_tuple(tuple);
  builder_.add_reader(reader);
  builder_.add_tensor_array(tensor_array);
  builder_.add_lod_tensor(lod_tensor);
  builder_.add_selected_rows(selected_rows);
  builder_.add_type(type);
  return builder_.Finish();
}

namespace VarType_ {

struct TensorDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_DIMS = 6
  };
  paddle::lite::fbs::VarType_::Type data_type() const {
    return static_cast<paddle::lite::fbs::VarType_::Type>(GetField<int32_t>(VT_DATA_TYPE, 0));
  }
  const flatbuffers::Vector<int64_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
};

struct TensorDescBuilder {
  typedef TensorDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(paddle::lite::fbs::VarType_::Type data_type) {
    fbb_.AddElement<int32_t>(TensorDesc::VT_DATA_TYPE, static_cast<int32_t>(data_type), 0);
  }
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims) {
    fbb_.AddOffset(TensorDesc::VT_DIMS, dims);
  }
  explicit TensorDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorDesc> CreateTensorDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    paddle::lite::fbs::VarType_::Type data_type = paddle::lite::fbs::VarType_::Type_BOOL,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims = 0) {
  TensorDescBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TensorDesc> CreateTensorDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    paddle::lite::fbs::VarType_::Type data_type = paddle::lite::fbs::VarType_::Type_BOOL,
    const std::vector<int64_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
  return paddle::lite::fbs::VarType_::CreateTensorDesc(
      _fbb,
      data_type,
      dims__);
}

struct LoDTensorDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoDTensorDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSOR = 4,
    VT_LOD_LEVEL = 6
  };
  const paddle::lite::fbs::VarType_::TensorDesc *tensor() const {
    return GetPointer<const paddle::lite::fbs::VarType_::TensorDesc *>(VT_TENSOR);
  }
  int32_t lod_level() const {
    return GetField<int32_t>(VT_LOD_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TENSOR) &&
           verifier.VerifyTable(tensor()) &&
           VerifyField<int32_t>(verifier, VT_LOD_LEVEL) &&
           verifier.EndTable();
  }
};

struct LoDTensorDescBuilder {
  typedef LoDTensorDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tensor(flatbuffers::Offset<paddle::lite::fbs::VarType_::TensorDesc> tensor) {
    fbb_.AddOffset(LoDTensorDesc::VT_TENSOR, tensor);
  }
  void add_lod_level(int32_t lod_level) {
    fbb_.AddElement<int32_t>(LoDTensorDesc::VT_LOD_LEVEL, lod_level, 0);
  }
  explicit LoDTensorDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LoDTensorDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoDTensorDesc>(end);
    fbb_.Required(o, LoDTensorDesc::VT_TENSOR);
    return o;
  }
};

inline flatbuffers::Offset<LoDTensorDesc> CreateLoDTensorDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<paddle::lite::fbs::VarType_::TensorDesc> tensor = 0,
    int32_t lod_level = 0) {
  LoDTensorDescBuilder builder_(_fbb);
  builder_.add_lod_level(lod_level);
  builder_.add_tensor(tensor);
  return builder_.Finish();
}

struct LoDTensorArrayDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoDTensorArrayDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSOR = 4,
    VT_LOD_LEVEL = 6
  };
  const paddle::lite::fbs::VarType_::TensorDesc *tensor() const {
    return GetPointer<const paddle::lite::fbs::VarType_::TensorDesc *>(VT_TENSOR);
  }
  int32_t lod_level() const {
    return GetField<int32_t>(VT_LOD_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TENSOR) &&
           verifier.VerifyTable(tensor()) &&
           VerifyField<int32_t>(verifier, VT_LOD_LEVEL) &&
           verifier.EndTable();
  }
};

struct LoDTensorArrayDescBuilder {
  typedef LoDTensorArrayDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tensor(flatbuffers::Offset<paddle::lite::fbs::VarType_::TensorDesc> tensor) {
    fbb_.AddOffset(LoDTensorArrayDesc::VT_TENSOR, tensor);
  }
  void add_lod_level(int32_t lod_level) {
    fbb_.AddElement<int32_t>(LoDTensorArrayDesc::VT_LOD_LEVEL, lod_level, 0);
  }
  explicit LoDTensorArrayDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LoDTensorArrayDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoDTensorArrayDesc>(end);
    fbb_.Required(o, LoDTensorArrayDesc::VT_TENSOR);
    return o;
  }
};

inline flatbuffers::Offset<LoDTensorArrayDesc> CreateLoDTensorArrayDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<paddle::lite::fbs::VarType_::TensorDesc> tensor = 0,
    int32_t lod_level = 0) {
  LoDTensorArrayDescBuilder builder_(_fbb);
  builder_.add_lod_level(lod_level);
  builder_.add_tensor(tensor);
  return builder_.Finish();
}

struct ReaderDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReaderDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOD_TENSOR = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::VarType_::LoDTensorDesc>> *lod_tensor() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::VarType_::LoDTensorDesc>> *>(VT_LOD_TENSOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOD_TENSOR) &&
           verifier.VerifyVector(lod_tensor()) &&
           verifier.VerifyVectorOfTables(lod_tensor()) &&
           verifier.EndTable();
  }
};

struct ReaderDescBuilder {
  typedef ReaderDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lod_tensor(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::VarType_::LoDTensorDesc>>> lod_tensor) {
    fbb_.AddOffset(ReaderDesc::VT_LOD_TENSOR, lod_tensor);
  }
  explicit ReaderDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReaderDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReaderDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReaderDesc> CreateReaderDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::VarType_::LoDTensorDesc>>> lod_tensor = 0) {
  ReaderDescBuilder builder_(_fbb);
  builder_.add_lod_tensor(lod_tensor);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReaderDesc> CreateReaderDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<paddle::lite::fbs::VarType_::LoDTensorDesc>> *lod_tensor = nullptr) {
  auto lod_tensor__ = lod_tensor ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::VarType_::LoDTensorDesc>>(*lod_tensor) : 0;
  return paddle::lite::fbs::VarType_::CreateReaderDesc(
      _fbb,
      lod_tensor__);
}

struct Tuple FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TupleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENT_TYPE = 4
  };
  const flatbuffers::Vector<int32_t> *element_type() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ELEMENT_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ELEMENT_TYPE) &&
           verifier.VerifyVector(element_type()) &&
           verifier.EndTable();
  }
};

struct TupleBuilder {
  typedef Tuple Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_element_type(flatbuffers::Offset<flatbuffers::Vector<int32_t>> element_type) {
    fbb_.AddOffset(Tuple::VT_ELEMENT_TYPE, element_type);
  }
  explicit TupleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Tuple> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tuple>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tuple> CreateTuple(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> element_type = 0) {
  TupleBuilder builder_(_fbb);
  builder_.add_element_type(element_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tuple> CreateTupleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *element_type = nullptr) {
  auto element_type__ = element_type ? _fbb.CreateVector<int32_t>(*element_type) : 0;
  return paddle::lite::fbs::VarType_::CreateTuple(
      _fbb,
      element_type__);
}

}  // namespace VarType_

struct VarDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VarDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_PERSISTABLE = 8,
    VT_NEED_CHECK_FEED = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const paddle::lite::fbs::VarType *type() const {
    return GetPointer<const paddle::lite::fbs::VarType *>(VT_TYPE);
  }
  bool persistable() const {
    return GetField<uint8_t>(VT_PERSISTABLE, 0) != 0;
  }
  bool need_check_feed() const {
    return GetField<uint8_t>(VT_NEED_CHECK_FEED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           VerifyField<uint8_t>(verifier, VT_PERSISTABLE) &&
           VerifyField<uint8_t>(verifier, VT_NEED_CHECK_FEED) &&
           verifier.EndTable();
  }
};

struct VarDescBuilder {
  typedef VarDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(VarDesc::VT_NAME, name);
  }
  void add_type(flatbuffers::Offset<paddle::lite::fbs::VarType> type) {
    fbb_.AddOffset(VarDesc::VT_TYPE, type);
  }
  void add_persistable(bool persistable) {
    fbb_.AddElement<uint8_t>(VarDesc::VT_PERSISTABLE, static_cast<uint8_t>(persistable), 0);
  }
  void add_need_check_feed(bool need_check_feed) {
    fbb_.AddElement<uint8_t>(VarDesc::VT_NEED_CHECK_FEED, static_cast<uint8_t>(need_check_feed), 0);
  }
  explicit VarDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VarDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VarDesc>(end);
    fbb_.Required(o, VarDesc::VT_NAME);
    fbb_.Required(o, VarDesc::VT_TYPE);
    return o;
  }
};

inline flatbuffers::Offset<VarDesc> CreateVarDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<paddle::lite::fbs::VarType> type = 0,
    bool persistable = false,
    bool need_check_feed = false) {
  VarDescBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_need_check_feed(need_check_feed);
  builder_.add_persistable(persistable);
  return builder_.Finish();
}

inline flatbuffers::Offset<VarDesc> CreateVarDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<paddle::lite::fbs::VarType> type = 0,
    bool persistable = false,
    bool need_check_feed = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return paddle::lite::fbs::CreateVarDesc(
      _fbb,
      name__,
      type,
      persistable,
      need_check_feed);
}

struct BlockDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BlockDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDX = 4,
    VT_PARENT_IDX = 6,
    VT_VARS = 8,
    VT_OPS = 10,
    VT_FORWARD_BLOCK_IDX = 12
  };
  int32_t idx() const {
    return GetField<int32_t>(VT_IDX, 0);
  }
  int32_t parent_idx() const {
    return GetField<int32_t>(VT_PARENT_IDX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::VarDesc>> *vars() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::VarDesc>> *>(VT_VARS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc>> *ops() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc>> *>(VT_OPS);
  }
  int32_t forward_block_idx() const {
    return GetField<int32_t>(VT_FORWARD_BLOCK_IDX, -1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_IDX) &&
           VerifyField<int32_t>(verifier, VT_PARENT_IDX) &&
           VerifyOffset(verifier, VT_VARS) &&
           verifier.VerifyVector(vars()) &&
           verifier.VerifyVectorOfTables(vars()) &&
           VerifyOffset(verifier, VT_OPS) &&
           verifier.VerifyVector(ops()) &&
           verifier.VerifyVectorOfTables(ops()) &&
           VerifyField<int32_t>(verifier, VT_FORWARD_BLOCK_IDX) &&
           verifier.EndTable();
  }
};

struct BlockDescBuilder {
  typedef BlockDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_idx(int32_t idx) {
    fbb_.AddElement<int32_t>(BlockDesc::VT_IDX, idx, 0);
  }
  void add_parent_idx(int32_t parent_idx) {
    fbb_.AddElement<int32_t>(BlockDesc::VT_PARENT_IDX, parent_idx, 0);
  }
  void add_vars(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::VarDesc>>> vars) {
    fbb_.AddOffset(BlockDesc::VT_VARS, vars);
  }
  void add_ops(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc>>> ops) {
    fbb_.AddOffset(BlockDesc::VT_OPS, ops);
  }
  void add_forward_block_idx(int32_t forward_block_idx) {
    fbb_.AddElement<int32_t>(BlockDesc::VT_FORWARD_BLOCK_IDX, forward_block_idx, -1);
  }
  explicit BlockDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BlockDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlockDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlockDesc> CreateBlockDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t idx = 0,
    int32_t parent_idx = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::VarDesc>>> vars = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc>>> ops = 0,
    int32_t forward_block_idx = -1) {
  BlockDescBuilder builder_(_fbb);
  builder_.add_forward_block_idx(forward_block_idx);
  builder_.add_ops(ops);
  builder_.add_vars(vars);
  builder_.add_parent_idx(parent_idx);
  builder_.add_idx(idx);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlockDesc> CreateBlockDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t idx = 0,
    int32_t parent_idx = 0,
    const std::vector<flatbuffers::Offset<paddle::lite::fbs::VarDesc>> *vars = nullptr,
    const std::vector<flatbuffers::Offset<paddle::lite::fbs::OpDesc>> *ops = nullptr,
    int32_t forward_block_idx = -1) {
  auto vars__ = vars ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::VarDesc>>(*vars) : 0;
  auto ops__ = ops ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::OpDesc>>(*ops) : 0;
  return paddle::lite::fbs::CreateBlockDesc(
      _fbb,
      idx,
      parent_idx,
      vars__,
      ops__,
      forward_block_idx);
}

struct CompatibleInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CompatibleInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_TYPE = 6
  };
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  paddle::lite::fbs::CompatibleInfo_::Type type() const {
    return static_cast<paddle::lite::fbs::CompatibleInfo_::Type>(GetField<int32_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct CompatibleInfoBuilder {
  typedef CompatibleInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(CompatibleInfo::VT_VERSION, version);
  }
  void add_type(paddle::lite::fbs::CompatibleInfo_::Type type) {
    fbb_.AddElement<int32_t>(CompatibleInfo::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  explicit CompatibleInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CompatibleInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompatibleInfo>(end);
    fbb_.Required(o, CompatibleInfo::VT_VERSION);
    return o;
  }
};

inline flatbuffers::Offset<CompatibleInfo> CreateCompatibleInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    paddle::lite::fbs::CompatibleInfo_::Type type = paddle::lite::fbs::CompatibleInfo_::Type_COMPATIBLE) {
  CompatibleInfoBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompatibleInfo> CreateCompatibleInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    paddle::lite::fbs::CompatibleInfo_::Type type = paddle::lite::fbs::CompatibleInfo_::Type_COMPATIBLE) {
  auto version__ = version ? _fbb.CreateString(version) : 0;
  return paddle::lite::fbs::CreateCompatibleInfo(
      _fbb,
      version__,
      type);
}

struct OpCompatibleMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpCompatibleMapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAIR = 4,
    VT_DEFAULT_REQUIRED_VERSION = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpCompatibleMap_::OpCompatiblePair>> *pair() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpCompatibleMap_::OpCompatiblePair>> *>(VT_PAIR);
  }
  const flatbuffers::String *default_required_version() const {
    return GetPointer<const flatbuffers::String *>(VT_DEFAULT_REQUIRED_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAIR) &&
           verifier.VerifyVector(pair()) &&
           verifier.VerifyVectorOfTables(pair()) &&
           VerifyOffset(verifier, VT_DEFAULT_REQUIRED_VERSION) &&
           verifier.VerifyString(default_required_version()) &&
           verifier.EndTable();
  }
};

struct OpCompatibleMapBuilder {
  typedef OpCompatibleMap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pair(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpCompatibleMap_::OpCompatiblePair>>> pair) {
    fbb_.AddOffset(OpCompatibleMap::VT_PAIR, pair);
  }
  void add_default_required_version(flatbuffers::Offset<flatbuffers::String> default_required_version) {
    fbb_.AddOffset(OpCompatibleMap::VT_DEFAULT_REQUIRED_VERSION, default_required_version);
  }
  explicit OpCompatibleMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OpCompatibleMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpCompatibleMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<OpCompatibleMap> CreateOpCompatibleMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::OpCompatibleMap_::OpCompatiblePair>>> pair = 0,
    flatbuffers::Offset<flatbuffers::String> default_required_version = 0) {
  OpCompatibleMapBuilder builder_(_fbb);
  builder_.add_default_required_version(default_required_version);
  builder_.add_pair(pair);
  return builder_.Finish();
}

inline flatbuffers::Offset<OpCompatibleMap> CreateOpCompatibleMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<paddle::lite::fbs::OpCompatibleMap_::OpCompatiblePair>> *pair = nullptr,
    const char *default_required_version = nullptr) {
  auto pair__ = pair ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::OpCompatibleMap_::OpCompatiblePair>>(*pair) : 0;
  auto default_required_version__ = default_required_version ? _fbb.CreateString(default_required_version) : 0;
  return paddle::lite::fbs::CreateOpCompatibleMap(
      _fbb,
      pair__,
      default_required_version__);
}

namespace OpCompatibleMap_ {

struct OpCompatiblePair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpCompatiblePairBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_NAME = 4,
    VT_COMPATIBLE_INFO = 6
  };
  const flatbuffers::String *op_name() const {
    return GetPointer<const flatbuffers::String *>(VT_OP_NAME);
  }
  const paddle::lite::fbs::CompatibleInfo *compatible_info() const {
    return GetPointer<const paddle::lite::fbs::CompatibleInfo *>(VT_COMPATIBLE_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_OP_NAME) &&
           verifier.VerifyString(op_name()) &&
           VerifyOffsetRequired(verifier, VT_COMPATIBLE_INFO) &&
           verifier.VerifyTable(compatible_info()) &&
           verifier.EndTable();
  }
};

struct OpCompatiblePairBuilder {
  typedef OpCompatiblePair Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_op_name(flatbuffers::Offset<flatbuffers::String> op_name) {
    fbb_.AddOffset(OpCompatiblePair::VT_OP_NAME, op_name);
  }
  void add_compatible_info(flatbuffers::Offset<paddle::lite::fbs::CompatibleInfo> compatible_info) {
    fbb_.AddOffset(OpCompatiblePair::VT_COMPATIBLE_INFO, compatible_info);
  }
  explicit OpCompatiblePairBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OpCompatiblePair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpCompatiblePair>(end);
    fbb_.Required(o, OpCompatiblePair::VT_OP_NAME);
    fbb_.Required(o, OpCompatiblePair::VT_COMPATIBLE_INFO);
    return o;
  }
};

inline flatbuffers::Offset<OpCompatiblePair> CreateOpCompatiblePair(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> op_name = 0,
    flatbuffers::Offset<paddle::lite::fbs::CompatibleInfo> compatible_info = 0) {
  OpCompatiblePairBuilder builder_(_fbb);
  builder_.add_compatible_info(compatible_info);
  builder_.add_op_name(op_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<OpCompatiblePair> CreateOpCompatiblePairDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *op_name = nullptr,
    flatbuffers::Offset<paddle::lite::fbs::CompatibleInfo> compatible_info = 0) {
  auto op_name__ = op_name ? _fbb.CreateString(op_name) : 0;
  return paddle::lite::fbs::OpCompatibleMap_::CreateOpCompatiblePair(
      _fbb,
      op_name__,
      compatible_info);
}

}  // namespace OpCompatibleMap_

struct ProgramDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProgramDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKS = 4,
    VT_VERSION = 6,
    VT_OP_COMPATIBLE_MAP = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::BlockDesc>> *blocks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::BlockDesc>> *>(VT_BLOCKS);
  }
  const paddle::lite::fbs::Version *version() const {
    return GetPointer<const paddle::lite::fbs::Version *>(VT_VERSION);
  }
  const paddle::lite::fbs::OpCompatibleMap *op_compatible_map() const {
    return GetPointer<const paddle::lite::fbs::OpCompatibleMap *>(VT_OP_COMPATIBLE_MAP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCKS) &&
           verifier.VerifyVector(blocks()) &&
           verifier.VerifyVectorOfTables(blocks()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyTable(version()) &&
           VerifyOffset(verifier, VT_OP_COMPATIBLE_MAP) &&
           verifier.VerifyTable(op_compatible_map()) &&
           verifier.EndTable();
  }
};

struct ProgramDescBuilder {
  typedef ProgramDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blocks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::BlockDesc>>> blocks) {
    fbb_.AddOffset(ProgramDesc::VT_BLOCKS, blocks);
  }
  void add_version(flatbuffers::Offset<paddle::lite::fbs::Version> version) {
    fbb_.AddOffset(ProgramDesc::VT_VERSION, version);
  }
  void add_op_compatible_map(flatbuffers::Offset<paddle::lite::fbs::OpCompatibleMap> op_compatible_map) {
    fbb_.AddOffset(ProgramDesc::VT_OP_COMPATIBLE_MAP, op_compatible_map);
  }
  explicit ProgramDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProgramDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProgramDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProgramDesc> CreateProgramDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::BlockDesc>>> blocks = 0,
    flatbuffers::Offset<paddle::lite::fbs::Version> version = 0,
    flatbuffers::Offset<paddle::lite::fbs::OpCompatibleMap> op_compatible_map = 0) {
  ProgramDescBuilder builder_(_fbb);
  builder_.add_op_compatible_map(op_compatible_map);
  builder_.add_version(version);
  builder_.add_blocks(blocks);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProgramDesc> CreateProgramDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<paddle::lite::fbs::BlockDesc>> *blocks = nullptr,
    flatbuffers::Offset<paddle::lite::fbs::Version> version = 0,
    flatbuffers::Offset<paddle::lite::fbs::OpCompatibleMap> op_compatible_map = 0) {
  auto blocks__ = blocks ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::BlockDesc>>(*blocks) : 0;
  return paddle::lite::fbs::CreateProgramDesc(
      _fbb,
      blocks__,
      version,
      op_compatible_map);
}

namespace OpDesc_ {

}  // namespace OpDesc_

namespace VarType_ {

}  // namespace VarType_

namespace OpCompatibleMap_ {

}  // namespace OpCompatibleMap_

inline const paddle::lite::fbs::ProgramDesc *GetProgramDesc(const void *buf) {
  return flatbuffers::GetRoot<paddle::lite::fbs::ProgramDesc>(buf);
}

inline const paddle::lite::fbs::ProgramDesc *GetSizePrefixedProgramDesc(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<paddle::lite::fbs::ProgramDesc>(buf);
}

inline bool VerifyProgramDescBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<paddle::lite::fbs::ProgramDesc>(nullptr);
}

inline bool VerifySizePrefixedProgramDescBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<paddle::lite::fbs::ProgramDesc>(nullptr);
}

inline void FinishProgramDescBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<paddle::lite::fbs::ProgramDesc> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedProgramDescBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<paddle::lite::fbs::ProgramDesc> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fbs
}  // namespace lite
}  // namespace paddle

#endif  // FLATBUFFERS_GENERATED_FRAMEWORK_PADDLE_LITE_FBS_H_
