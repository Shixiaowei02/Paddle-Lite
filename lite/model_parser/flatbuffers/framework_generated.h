// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FRAMEWORK_PADDLE_LITE_FBS_PROTO_H_
#define FLATBUFFERS_GENERATED_FRAMEWORK_PADDLE_LITE_FBS_PROTO_H_

#include "flatbuffers/flatbuffers.h"

namespace paddle {
namespace lite {
namespace fbs {
namespace proto {

struct Version;
struct VersionBuilder;
struct VersionT;

struct OpDesc;
struct OpDescBuilder;
struct OpDescT;

namespace OpDesc_ {

struct Attr;
struct AttrBuilder;
struct AttrT;

struct Var;
struct VarBuilder;
struct VarT;

}  // namespace OpDesc_

struct VarType;
struct VarTypeBuilder;
struct VarTypeT;

namespace VarType_ {

struct TensorDesc;
struct TensorDescBuilder;
struct TensorDescT;

struct LoDTensorDesc;
struct LoDTensorDescBuilder;
struct LoDTensorDescT;

struct LoDTensorArrayDesc;
struct LoDTensorArrayDescBuilder;
struct LoDTensorArrayDescT;

struct ReaderDesc;
struct ReaderDescBuilder;
struct ReaderDescT;

struct Tuple;
struct TupleBuilder;
struct TupleT;

}  // namespace VarType_

struct VarDesc;
struct VarDescBuilder;
struct VarDescT;

struct BlockDesc;
struct BlockDescBuilder;
struct BlockDescT;

struct CompatibleInfo;
struct CompatibleInfoBuilder;
struct CompatibleInfoT;

struct OpCompatibleMap;
struct OpCompatibleMapBuilder;
struct OpCompatibleMapT;

namespace OpCompatibleMap_ {

struct OpCompatiblePair;
struct OpCompatiblePairBuilder;
struct OpCompatiblePairT;

}  // namespace OpCompatibleMap_

struct ProgramDesc;
struct ProgramDescBuilder;
struct ProgramDescT;

enum AttrType {
  AttrType_INT = 0,
  AttrType_FLOAT = 1,
  AttrType_STRING = 2,
  AttrType_INTS = 3,
  AttrType_FLOATS = 4,
  AttrType_STRINGS = 5,
  AttrType_BOOLEAN = 6,
  AttrType_BOOLEANS = 7,
  AttrType_BLOCK = 8,
  AttrType_LONG = 9,
  AttrType_BLOCKS = 10,
  AttrType_LONGS = 11,
  AttrType_MIN = AttrType_INT,
  AttrType_MAX = AttrType_LONGS
};

inline const AttrType (&EnumValuesAttrType())[12] {
  static const AttrType values[] = {
    AttrType_INT,
    AttrType_FLOAT,
    AttrType_STRING,
    AttrType_INTS,
    AttrType_FLOATS,
    AttrType_STRINGS,
    AttrType_BOOLEAN,
    AttrType_BOOLEANS,
    AttrType_BLOCK,
    AttrType_LONG,
    AttrType_BLOCKS,
    AttrType_LONGS
  };
  return values;
}

inline const char * const *EnumNamesAttrType() {
  static const char * const names[13] = {
    "INT",
    "FLOAT",
    "STRING",
    "INTS",
    "FLOATS",
    "STRINGS",
    "BOOLEAN",
    "BOOLEANS",
    "BLOCK",
    "LONG",
    "BLOCKS",
    "LONGS",
    nullptr
  };
  return names;
}

inline const char *EnumNameAttrType(AttrType e) {
  if (flatbuffers::IsOutRange(e, AttrType_INT, AttrType_LONGS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAttrType()[index];
}

namespace VarType_ {

enum Type {
  Type_BOOL = 0,
  Type_INT16 = 1,
  Type_INT32 = 2,
  Type_INT64 = 3,
  Type_FP16 = 4,
  Type_FP32 = 5,
  Type_FP64 = 6,
  Type_LOD_TENSOR = 7,
  Type_SELECTED_ROWS = 8,
  Type_FEED_MINIBATCH = 9,
  Type_FETCH_LIST = 10,
  Type_STEP_SCOPES = 11,
  Type_LOD_RANK_TABLE = 12,
  Type_LOD_TENSOR_ARRAY = 13,
  Type_PLACE_LIST = 14,
  Type_READER = 15,
  Type_RAW = 17,
  Type_TUPLE = 18,
  Type_SIZE_T = 19,
  Type_UINT8 = 20,
  Type_INT8 = 21,
  Type_MIN = Type_BOOL,
  Type_MAX = Type_INT8
};

inline const Type (&EnumValuesType())[21] {
  static const Type values[] = {
    Type_BOOL,
    Type_INT16,
    Type_INT32,
    Type_INT64,
    Type_FP16,
    Type_FP32,
    Type_FP64,
    Type_LOD_TENSOR,
    Type_SELECTED_ROWS,
    Type_FEED_MINIBATCH,
    Type_FETCH_LIST,
    Type_STEP_SCOPES,
    Type_LOD_RANK_TABLE,
    Type_LOD_TENSOR_ARRAY,
    Type_PLACE_LIST,
    Type_READER,
    Type_RAW,
    Type_TUPLE,
    Type_SIZE_T,
    Type_UINT8,
    Type_INT8
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[23] = {
    "BOOL",
    "INT16",
    "INT32",
    "INT64",
    "FP16",
    "FP32",
    "FP64",
    "LOD_TENSOR",
    "SELECTED_ROWS",
    "FEED_MINIBATCH",
    "FETCH_LIST",
    "STEP_SCOPES",
    "LOD_RANK_TABLE",
    "LOD_TENSOR_ARRAY",
    "PLACE_LIST",
    "READER",
    "",
    "RAW",
    "TUPLE",
    "SIZE_T",
    "UINT8",
    "INT8",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (flatbuffers::IsOutRange(e, Type_BOOL, Type_INT8)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

}  // namespace VarType_

namespace CompatibleInfo_ {

enum Type {
  Type_COMPATIBLE = 0,
  Type_DEFINITELY_NOT = 1,
  Type_POSSIBLE = 2,
  Type_BUG_FIX = 3,
  Type_PRECISION_CHANGE = 4,
  Type_MIN = Type_COMPATIBLE,
  Type_MAX = Type_PRECISION_CHANGE
};

inline const Type (&EnumValuesType())[5] {
  static const Type values[] = {
    Type_COMPATIBLE,
    Type_DEFINITELY_NOT,
    Type_POSSIBLE,
    Type_BUG_FIX,
    Type_PRECISION_CHANGE
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[6] = {
    "COMPATIBLE",
    "DEFINITELY_NOT",
    "POSSIBLE",
    "BUG_FIX",
    "PRECISION_CHANGE",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (flatbuffers::IsOutRange(e, Type_COMPATIBLE, Type_PRECISION_CHANGE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

}  // namespace CompatibleInfo_

struct VersionT : public flatbuffers::NativeTable {
  typedef Version TableType;
  int64_t version;
  VersionT()
      : version(0) {
  }
};

struct Version FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VersionT NativeTableType;
  typedef VersionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4
  };
  int64_t version() const {
    return GetField<int64_t>(VT_VERSION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VERSION) &&
           verifier.EndTable();
  }
  VersionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VersionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Version> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VersionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VersionBuilder {
  typedef Version Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(int64_t version) {
    fbb_.AddElement<int64_t>(Version::VT_VERSION, version, 0);
  }
  explicit VersionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Version> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Version>(end);
    return o;
  }
};

inline flatbuffers::Offset<Version> CreateVersion(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t version = 0) {
  VersionBuilder builder_(_fbb);
  builder_.add_version(version);
  return builder_.Finish();
}

flatbuffers::Offset<Version> CreateVersion(flatbuffers::FlatBufferBuilder &_fbb, const VersionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OpDescT : public flatbuffers::NativeTable {
  typedef OpDesc TableType;
  std::string type;
  std::vector<std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::VarT>> inputs;
  std::vector<std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::VarT>> outputs;
  std::vector<std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::AttrT>> attrs;
  bool is_target;
  OpDescT()
      : is_target(false) {
  }
};

struct OpDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpDescT NativeTableType;
  typedef OpDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_ATTRS = 10,
    VT_IS_TARGET = 12
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Attr>> *attrs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Attr>> *>(VT_ATTRS);
  }
  bool is_target() const {
    return GetField<uint8_t>(VT_IS_TARGET, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           VerifyOffset(verifier, VT_ATTRS) &&
           verifier.VerifyVector(attrs()) &&
           verifier.VerifyVectorOfTables(attrs()) &&
           VerifyField<uint8_t>(verifier, VT_IS_TARGET) &&
           verifier.EndTable();
  }
  OpDescT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OpDescT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OpDesc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpDescT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OpDescBuilder {
  typedef OpDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(OpDesc::VT_TYPE, type);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>>> inputs) {
    fbb_.AddOffset(OpDesc::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>>> outputs) {
    fbb_.AddOffset(OpDesc::VT_OUTPUTS, outputs);
  }
  void add_attrs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Attr>>> attrs) {
    fbb_.AddOffset(OpDesc::VT_ATTRS, attrs);
  }
  void add_is_target(bool is_target) {
    fbb_.AddElement<uint8_t>(OpDesc::VT_IS_TARGET, static_cast<uint8_t>(is_target), 0);
  }
  explicit OpDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OpDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpDesc>(end);
    fbb_.Required(o, OpDesc::VT_TYPE);
    return o;
  }
};

inline flatbuffers::Offset<OpDesc> CreateOpDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Attr>>> attrs = 0,
    bool is_target = false) {
  OpDescBuilder builder_(_fbb);
  builder_.add_attrs(attrs);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_type(type);
  builder_.add_is_target(is_target);
  return builder_.Finish();
}

inline flatbuffers::Offset<OpDesc> CreateOpDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    std::vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> *inputs = nullptr,
    std::vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> *outputs = nullptr,
    std::vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Attr>> *attrs = nullptr,
    bool is_target = false) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVectorOfSortedTables<paddle::lite::fbs::proto::OpDesc_::Var>(inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVectorOfSortedTables<paddle::lite::fbs::proto::OpDesc_::Var>(outputs) : 0;
  auto attrs__ = attrs ? _fbb.CreateVectorOfSortedTables<paddle::lite::fbs::proto::OpDesc_::Attr>(attrs) : 0;
  return paddle::lite::fbs::proto::CreateOpDesc(
      _fbb,
      type__,
      inputs__,
      outputs__,
      attrs__,
      is_target);
}

flatbuffers::Offset<OpDesc> CreateOpDesc(flatbuffers::FlatBufferBuilder &_fbb, const OpDescT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace OpDesc_ {

struct AttrT : public flatbuffers::NativeTable {
  typedef Attr TableType;
  std::string name;
  paddle::lite::fbs::proto::AttrType type;
  int32_t i;
  float f;
  std::string s;
  std::vector<int32_t> ints;
  std::vector<float> floats;
  std::vector<std::string> strings;
  bool b;
  std::vector<bool> bools;
  int32_t block_idx;
  int64_t l;
  std::vector<int32_t> blocks_idx;
  std::vector<int64_t> longs;
  AttrT()
      : type(paddle::lite::fbs::proto::AttrType_INT),
        i(0),
        f(0.0f),
        b(false),
        block_idx(0),
        l(0) {
  }
};

struct Attr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttrT NativeTableType;
  typedef AttrBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_I = 8,
    VT_F = 10,
    VT_S = 12,
    VT_INTS = 14,
    VT_FLOATS = 16,
    VT_STRINGS = 18,
    VT_B = 20,
    VT_BOOLS = 22,
    VT_BLOCK_IDX = 24,
    VT_L = 26,
    VT_BLOCKS_IDX = 28,
    VT_LONGS = 30
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const Attr *o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(name()->c_str(), val);
  }
  paddle::lite::fbs::proto::AttrType type() const {
    return static_cast<paddle::lite::fbs::proto::AttrType>(GetField<int32_t>(VT_TYPE, 0));
  }
  int32_t i() const {
    return GetField<int32_t>(VT_I, 0);
  }
  float f() const {
    return GetField<float>(VT_F, 0.0f);
  }
  const flatbuffers::String *s() const {
    return GetPointer<const flatbuffers::String *>(VT_S);
  }
  const flatbuffers::Vector<int32_t> *ints() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INTS);
  }
  const flatbuffers::Vector<float> *floats() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_FLOATS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *strings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_STRINGS);
  }
  bool b() const {
    return GetField<uint8_t>(VT_B, 0) != 0;
  }
  const flatbuffers::Vector<uint8_t> *bools() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BOOLS);
  }
  int32_t block_idx() const {
    return GetField<int32_t>(VT_BLOCK_IDX, 0);
  }
  int64_t l() const {
    return GetField<int64_t>(VT_L, 0);
  }
  const flatbuffers::Vector<int32_t> *blocks_idx() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCKS_IDX);
  }
  const flatbuffers::Vector<int64_t> *longs() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_LONGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_I) &&
           VerifyField<float>(verifier, VT_F) &&
           VerifyOffset(verifier, VT_S) &&
           verifier.VerifyString(s()) &&
           VerifyOffset(verifier, VT_INTS) &&
           verifier.VerifyVector(ints()) &&
           VerifyOffset(verifier, VT_FLOATS) &&
           verifier.VerifyVector(floats()) &&
           VerifyOffset(verifier, VT_STRINGS) &&
           verifier.VerifyVector(strings()) &&
           verifier.VerifyVectorOfStrings(strings()) &&
           VerifyField<uint8_t>(verifier, VT_B) &&
           VerifyOffset(verifier, VT_BOOLS) &&
           verifier.VerifyVector(bools()) &&
           VerifyField<int32_t>(verifier, VT_BLOCK_IDX) &&
           VerifyField<int64_t>(verifier, VT_L) &&
           VerifyOffset(verifier, VT_BLOCKS_IDX) &&
           verifier.VerifyVector(blocks_idx()) &&
           VerifyOffset(verifier, VT_LONGS) &&
           verifier.VerifyVector(longs()) &&
           verifier.EndTable();
  }
  AttrT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AttrT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Attr> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttrT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AttrBuilder {
  typedef Attr Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Attr::VT_NAME, name);
  }
  void add_type(paddle::lite::fbs::proto::AttrType type) {
    fbb_.AddElement<int32_t>(Attr::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_i(int32_t i) {
    fbb_.AddElement<int32_t>(Attr::VT_I, i, 0);
  }
  void add_f(float f) {
    fbb_.AddElement<float>(Attr::VT_F, f, 0.0f);
  }
  void add_s(flatbuffers::Offset<flatbuffers::String> s) {
    fbb_.AddOffset(Attr::VT_S, s);
  }
  void add_ints(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ints) {
    fbb_.AddOffset(Attr::VT_INTS, ints);
  }
  void add_floats(flatbuffers::Offset<flatbuffers::Vector<float>> floats) {
    fbb_.AddOffset(Attr::VT_FLOATS, floats);
  }
  void add_strings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> strings) {
    fbb_.AddOffset(Attr::VT_STRINGS, strings);
  }
  void add_b(bool b) {
    fbb_.AddElement<uint8_t>(Attr::VT_B, static_cast<uint8_t>(b), 0);
  }
  void add_bools(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bools) {
    fbb_.AddOffset(Attr::VT_BOOLS, bools);
  }
  void add_block_idx(int32_t block_idx) {
    fbb_.AddElement<int32_t>(Attr::VT_BLOCK_IDX, block_idx, 0);
  }
  void add_l(int64_t l) {
    fbb_.AddElement<int64_t>(Attr::VT_L, l, 0);
  }
  void add_blocks_idx(flatbuffers::Offset<flatbuffers::Vector<int32_t>> blocks_idx) {
    fbb_.AddOffset(Attr::VT_BLOCKS_IDX, blocks_idx);
  }
  void add_longs(flatbuffers::Offset<flatbuffers::Vector<int64_t>> longs) {
    fbb_.AddOffset(Attr::VT_LONGS, longs);
  }
  explicit AttrBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Attr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Attr>(end);
    fbb_.Required(o, Attr::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Attr> CreateAttr(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    paddle::lite::fbs::proto::AttrType type = paddle::lite::fbs::proto::AttrType_INT,
    int32_t i = 0,
    float f = 0.0f,
    flatbuffers::Offset<flatbuffers::String> s = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ints = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> floats = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> strings = 0,
    bool b = false,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bools = 0,
    int32_t block_idx = 0,
    int64_t l = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> blocks_idx = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> longs = 0) {
  AttrBuilder builder_(_fbb);
  builder_.add_l(l);
  builder_.add_longs(longs);
  builder_.add_blocks_idx(blocks_idx);
  builder_.add_block_idx(block_idx);
  builder_.add_bools(bools);
  builder_.add_strings(strings);
  builder_.add_floats(floats);
  builder_.add_ints(ints);
  builder_.add_s(s);
  builder_.add_f(f);
  builder_.add_i(i);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_b(b);
  return builder_.Finish();
}

inline flatbuffers::Offset<Attr> CreateAttrDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    paddle::lite::fbs::proto::AttrType type = paddle::lite::fbs::proto::AttrType_INT,
    int32_t i = 0,
    float f = 0.0f,
    const char *s = nullptr,
    const std::vector<int32_t> *ints = nullptr,
    const std::vector<float> *floats = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *strings = nullptr,
    bool b = false,
    const std::vector<uint8_t> *bools = nullptr,
    int32_t block_idx = 0,
    int64_t l = 0,
    const std::vector<int32_t> *blocks_idx = nullptr,
    const std::vector<int64_t> *longs = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto s__ = s ? _fbb.CreateString(s) : 0;
  auto ints__ = ints ? _fbb.CreateVector<int32_t>(*ints) : 0;
  auto floats__ = floats ? _fbb.CreateVector<float>(*floats) : 0;
  auto strings__ = strings ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*strings) : 0;
  auto bools__ = bools ? _fbb.CreateVector<uint8_t>(*bools) : 0;
  auto blocks_idx__ = blocks_idx ? _fbb.CreateVector<int32_t>(*blocks_idx) : 0;
  auto longs__ = longs ? _fbb.CreateVector<int64_t>(*longs) : 0;
  return paddle::lite::fbs::proto::OpDesc_::CreateAttr(
      _fbb,
      name__,
      type,
      i,
      f,
      s__,
      ints__,
      floats__,
      strings__,
      b,
      bools__,
      block_idx,
      l,
      blocks_idx__,
      longs__);
}

flatbuffers::Offset<Attr> CreateAttr(flatbuffers::FlatBufferBuilder &_fbb, const AttrT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VarT : public flatbuffers::NativeTable {
  typedef Var TableType;
  std::string parameter;
  std::vector<std::string> arguments;
  VarT() {
  }
};

struct Var FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VarT NativeTableType;
  typedef VarBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETER = 4,
    VT_ARGUMENTS = 6
  };
  const flatbuffers::String *parameter() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAMETER);
  }
  bool KeyCompareLessThan(const Var *o) const {
    return *parameter() < *o->parameter();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(parameter()->c_str(), val);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ARGUMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PARAMETER) &&
           verifier.VerifyString(parameter()) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfStrings(arguments()) &&
           verifier.EndTable();
  }
  VarT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VarT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Var> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VarBuilder {
  typedef Var Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_parameter(flatbuffers::Offset<flatbuffers::String> parameter) {
    fbb_.AddOffset(Var::VT_PARAMETER, parameter);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> arguments) {
    fbb_.AddOffset(Var::VT_ARGUMENTS, arguments);
  }
  explicit VarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Var> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Var>(end);
    fbb_.Required(o, Var::VT_PARAMETER);
    return o;
  }
};

inline flatbuffers::Offset<Var> CreateVar(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> parameter = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> arguments = 0) {
  VarBuilder builder_(_fbb);
  builder_.add_arguments(arguments);
  builder_.add_parameter(parameter);
  return builder_.Finish();
}

inline flatbuffers::Offset<Var> CreateVarDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *parameter = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *arguments = nullptr) {
  auto parameter__ = parameter ? _fbb.CreateString(parameter) : 0;
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*arguments) : 0;
  return paddle::lite::fbs::proto::OpDesc_::CreateVar(
      _fbb,
      parameter__,
      arguments__);
}

flatbuffers::Offset<Var> CreateVar(flatbuffers::FlatBufferBuilder &_fbb, const VarT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace OpDesc_

struct VarTypeT : public flatbuffers::NativeTable {
  typedef VarType TableType;
  paddle::lite::fbs::proto::VarType_::Type type;
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::TensorDescT> selected_rows;
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorDescT> lod_tensor;
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorArrayDescT> tensor_array;
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::ReaderDescT> reader;
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::TupleT> tuple;
  VarTypeT()
      : type(paddle::lite::fbs::proto::VarType_::Type_BOOL) {
  }
};

struct VarType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VarTypeT NativeTableType;
  typedef VarTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_SELECTED_ROWS = 6,
    VT_LOD_TENSOR = 8,
    VT_TENSOR_ARRAY = 10,
    VT_READER = 12,
    VT_TUPLE = 14
  };
  paddle::lite::fbs::proto::VarType_::Type type() const {
    return static_cast<paddle::lite::fbs::proto::VarType_::Type>(GetField<int32_t>(VT_TYPE, 0));
  }
  const paddle::lite::fbs::proto::VarType_::TensorDesc *selected_rows() const {
    return GetPointer<const paddle::lite::fbs::proto::VarType_::TensorDesc *>(VT_SELECTED_ROWS);
  }
  const paddle::lite::fbs::proto::VarType_::LoDTensorDesc *lod_tensor() const {
    return GetPointer<const paddle::lite::fbs::proto::VarType_::LoDTensorDesc *>(VT_LOD_TENSOR);
  }
  const paddle::lite::fbs::proto::VarType_::LoDTensorArrayDesc *tensor_array() const {
    return GetPointer<const paddle::lite::fbs::proto::VarType_::LoDTensorArrayDesc *>(VT_TENSOR_ARRAY);
  }
  const paddle::lite::fbs::proto::VarType_::ReaderDesc *reader() const {
    return GetPointer<const paddle::lite::fbs::proto::VarType_::ReaderDesc *>(VT_READER);
  }
  const paddle::lite::fbs::proto::VarType_::Tuple *tuple() const {
    return GetPointer<const paddle::lite::fbs::proto::VarType_::Tuple *>(VT_TUPLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_SELECTED_ROWS) &&
           verifier.VerifyTable(selected_rows()) &&
           VerifyOffset(verifier, VT_LOD_TENSOR) &&
           verifier.VerifyTable(lod_tensor()) &&
           VerifyOffset(verifier, VT_TENSOR_ARRAY) &&
           verifier.VerifyTable(tensor_array()) &&
           VerifyOffset(verifier, VT_READER) &&
           verifier.VerifyTable(reader()) &&
           VerifyOffset(verifier, VT_TUPLE) &&
           verifier.VerifyTable(tuple()) &&
           verifier.EndTable();
  }
  VarTypeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VarTypeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<VarType> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarTypeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VarTypeBuilder {
  typedef VarType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(paddle::lite::fbs::proto::VarType_::Type type) {
    fbb_.AddElement<int32_t>(VarType::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_selected_rows(flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::TensorDesc> selected_rows) {
    fbb_.AddOffset(VarType::VT_SELECTED_ROWS, selected_rows);
  }
  void add_lod_tensor(flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc> lod_tensor) {
    fbb_.AddOffset(VarType::VT_LOD_TENSOR, lod_tensor);
  }
  void add_tensor_array(flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorArrayDesc> tensor_array) {
    fbb_.AddOffset(VarType::VT_TENSOR_ARRAY, tensor_array);
  }
  void add_reader(flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::ReaderDesc> reader) {
    fbb_.AddOffset(VarType::VT_READER, reader);
  }
  void add_tuple(flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::Tuple> tuple) {
    fbb_.AddOffset(VarType::VT_TUPLE, tuple);
  }
  explicit VarTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VarType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VarType>(end);
    return o;
  }
};

inline flatbuffers::Offset<VarType> CreateVarType(
    flatbuffers::FlatBufferBuilder &_fbb,
    paddle::lite::fbs::proto::VarType_::Type type = paddle::lite::fbs::proto::VarType_::Type_BOOL,
    flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::TensorDesc> selected_rows = 0,
    flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc> lod_tensor = 0,
    flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorArrayDesc> tensor_array = 0,
    flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::ReaderDesc> reader = 0,
    flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::Tuple> tuple = 0) {
  VarTypeBuilder builder_(_fbb);
  builder_.add_tuple(tuple);
  builder_.add_reader(reader);
  builder_.add_tensor_array(tensor_array);
  builder_.add_lod_tensor(lod_tensor);
  builder_.add_selected_rows(selected_rows);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<VarType> CreateVarType(flatbuffers::FlatBufferBuilder &_fbb, const VarTypeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace VarType_ {

struct TensorDescT : public flatbuffers::NativeTable {
  typedef TensorDesc TableType;
  paddle::lite::fbs::proto::VarType_::Type data_type;
  std::vector<int64_t> dims;
  TensorDescT()
      : data_type(paddle::lite::fbs::proto::VarType_::Type_BOOL) {
  }
};

struct TensorDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorDescT NativeTableType;
  typedef TensorDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_DIMS = 6
  };
  paddle::lite::fbs::proto::VarType_::Type data_type() const {
    return static_cast<paddle::lite::fbs::proto::VarType_::Type>(GetField<int32_t>(VT_DATA_TYPE, 0));
  }
  const flatbuffers::Vector<int64_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
  TensorDescT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorDescT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorDesc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorDescBuilder {
  typedef TensorDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(paddle::lite::fbs::proto::VarType_::Type data_type) {
    fbb_.AddElement<int32_t>(TensorDesc::VT_DATA_TYPE, static_cast<int32_t>(data_type), 0);
  }
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims) {
    fbb_.AddOffset(TensorDesc::VT_DIMS, dims);
  }
  explicit TensorDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorDesc> CreateTensorDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    paddle::lite::fbs::proto::VarType_::Type data_type = paddle::lite::fbs::proto::VarType_::Type_BOOL,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims = 0) {
  TensorDescBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TensorDesc> CreateTensorDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    paddle::lite::fbs::proto::VarType_::Type data_type = paddle::lite::fbs::proto::VarType_::Type_BOOL,
    const std::vector<int64_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
  return paddle::lite::fbs::proto::VarType_::CreateTensorDesc(
      _fbb,
      data_type,
      dims__);
}

flatbuffers::Offset<TensorDesc> CreateTensorDesc(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoDTensorDescT : public flatbuffers::NativeTable {
  typedef LoDTensorDesc TableType;
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::TensorDescT> tensor;
  int32_t lod_level;
  LoDTensorDescT()
      : lod_level(0) {
  }
};

struct LoDTensorDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoDTensorDescT NativeTableType;
  typedef LoDTensorDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSOR = 4,
    VT_LOD_LEVEL = 6
  };
  const paddle::lite::fbs::proto::VarType_::TensorDesc *tensor() const {
    return GetPointer<const paddle::lite::fbs::proto::VarType_::TensorDesc *>(VT_TENSOR);
  }
  int32_t lod_level() const {
    return GetField<int32_t>(VT_LOD_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TENSOR) &&
           verifier.VerifyTable(tensor()) &&
           VerifyField<int32_t>(verifier, VT_LOD_LEVEL) &&
           verifier.EndTable();
  }
  LoDTensorDescT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoDTensorDescT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LoDTensorDesc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoDTensorDescT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoDTensorDescBuilder {
  typedef LoDTensorDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tensor(flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::TensorDesc> tensor) {
    fbb_.AddOffset(LoDTensorDesc::VT_TENSOR, tensor);
  }
  void add_lod_level(int32_t lod_level) {
    fbb_.AddElement<int32_t>(LoDTensorDesc::VT_LOD_LEVEL, lod_level, 0);
  }
  explicit LoDTensorDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LoDTensorDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoDTensorDesc>(end);
    fbb_.Required(o, LoDTensorDesc::VT_TENSOR);
    return o;
  }
};

inline flatbuffers::Offset<LoDTensorDesc> CreateLoDTensorDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::TensorDesc> tensor = 0,
    int32_t lod_level = 0) {
  LoDTensorDescBuilder builder_(_fbb);
  builder_.add_lod_level(lod_level);
  builder_.add_tensor(tensor);
  return builder_.Finish();
}

flatbuffers::Offset<LoDTensorDesc> CreateLoDTensorDesc(flatbuffers::FlatBufferBuilder &_fbb, const LoDTensorDescT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoDTensorArrayDescT : public flatbuffers::NativeTable {
  typedef LoDTensorArrayDesc TableType;
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::TensorDescT> tensor;
  int32_t lod_level;
  LoDTensorArrayDescT()
      : lod_level(0) {
  }
};

struct LoDTensorArrayDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoDTensorArrayDescT NativeTableType;
  typedef LoDTensorArrayDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSOR = 4,
    VT_LOD_LEVEL = 6
  };
  const paddle::lite::fbs::proto::VarType_::TensorDesc *tensor() const {
    return GetPointer<const paddle::lite::fbs::proto::VarType_::TensorDesc *>(VT_TENSOR);
  }
  int32_t lod_level() const {
    return GetField<int32_t>(VT_LOD_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TENSOR) &&
           verifier.VerifyTable(tensor()) &&
           VerifyField<int32_t>(verifier, VT_LOD_LEVEL) &&
           verifier.EndTable();
  }
  LoDTensorArrayDescT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoDTensorArrayDescT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LoDTensorArrayDesc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoDTensorArrayDescT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoDTensorArrayDescBuilder {
  typedef LoDTensorArrayDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tensor(flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::TensorDesc> tensor) {
    fbb_.AddOffset(LoDTensorArrayDesc::VT_TENSOR, tensor);
  }
  void add_lod_level(int32_t lod_level) {
    fbb_.AddElement<int32_t>(LoDTensorArrayDesc::VT_LOD_LEVEL, lod_level, 0);
  }
  explicit LoDTensorArrayDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LoDTensorArrayDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoDTensorArrayDesc>(end);
    fbb_.Required(o, LoDTensorArrayDesc::VT_TENSOR);
    return o;
  }
};

inline flatbuffers::Offset<LoDTensorArrayDesc> CreateLoDTensorArrayDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::TensorDesc> tensor = 0,
    int32_t lod_level = 0) {
  LoDTensorArrayDescBuilder builder_(_fbb);
  builder_.add_lod_level(lod_level);
  builder_.add_tensor(tensor);
  return builder_.Finish();
}

flatbuffers::Offset<LoDTensorArrayDesc> CreateLoDTensorArrayDesc(flatbuffers::FlatBufferBuilder &_fbb, const LoDTensorArrayDescT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReaderDescT : public flatbuffers::NativeTable {
  typedef ReaderDesc TableType;
  std::vector<std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorDescT>> lod_tensor;
  ReaderDescT() {
  }
};

struct ReaderDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReaderDescT NativeTableType;
  typedef ReaderDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOD_TENSOR = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc>> *lod_tensor() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc>> *>(VT_LOD_TENSOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOD_TENSOR) &&
           verifier.VerifyVector(lod_tensor()) &&
           verifier.VerifyVectorOfTables(lod_tensor()) &&
           verifier.EndTable();
  }
  ReaderDescT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReaderDescT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReaderDesc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReaderDescT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReaderDescBuilder {
  typedef ReaderDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lod_tensor(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc>>> lod_tensor) {
    fbb_.AddOffset(ReaderDesc::VT_LOD_TENSOR, lod_tensor);
  }
  explicit ReaderDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReaderDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReaderDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReaderDesc> CreateReaderDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc>>> lod_tensor = 0) {
  ReaderDescBuilder builder_(_fbb);
  builder_.add_lod_tensor(lod_tensor);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReaderDesc> CreateReaderDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc>> *lod_tensor = nullptr) {
  auto lod_tensor__ = lod_tensor ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc>>(*lod_tensor) : 0;
  return paddle::lite::fbs::proto::VarType_::CreateReaderDesc(
      _fbb,
      lod_tensor__);
}

flatbuffers::Offset<ReaderDesc> CreateReaderDesc(flatbuffers::FlatBufferBuilder &_fbb, const ReaderDescT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TupleT : public flatbuffers::NativeTable {
  typedef Tuple TableType;
  std::vector<paddle::lite::fbs::proto::VarType_::Type> element_type;
  TupleT() {
  }
};

struct Tuple FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TupleT NativeTableType;
  typedef TupleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENT_TYPE = 4
  };
  const flatbuffers::Vector<int32_t> *element_type() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ELEMENT_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ELEMENT_TYPE) &&
           verifier.VerifyVector(element_type()) &&
           verifier.EndTable();
  }
  TupleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TupleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Tuple> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TupleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TupleBuilder {
  typedef Tuple Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_element_type(flatbuffers::Offset<flatbuffers::Vector<int32_t>> element_type) {
    fbb_.AddOffset(Tuple::VT_ELEMENT_TYPE, element_type);
  }
  explicit TupleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Tuple> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tuple>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tuple> CreateTuple(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> element_type = 0) {
  TupleBuilder builder_(_fbb);
  builder_.add_element_type(element_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tuple> CreateTupleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *element_type = nullptr) {
  auto element_type__ = element_type ? _fbb.CreateVector<int32_t>(*element_type) : 0;
  return paddle::lite::fbs::proto::VarType_::CreateTuple(
      _fbb,
      element_type__);
}

flatbuffers::Offset<Tuple> CreateTuple(flatbuffers::FlatBufferBuilder &_fbb, const TupleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace VarType_

struct VarDescT : public flatbuffers::NativeTable {
  typedef VarDesc TableType;
  std::string name;
  std::unique_ptr<paddle::lite::fbs::proto::VarTypeT> type;
  bool persistable;
  bool need_check_feed;
  VarDescT()
      : persistable(false),
        need_check_feed(false) {
  }
};

struct VarDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VarDescT NativeTableType;
  typedef VarDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_PERSISTABLE = 8,
    VT_NEED_CHECK_FEED = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const VarDesc *o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(name()->c_str(), val);
  }
  const paddle::lite::fbs::proto::VarType *type() const {
    return GetPointer<const paddle::lite::fbs::proto::VarType *>(VT_TYPE);
  }
  bool persistable() const {
    return GetField<uint8_t>(VT_PERSISTABLE, 0) != 0;
  }
  bool need_check_feed() const {
    return GetField<uint8_t>(VT_NEED_CHECK_FEED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           VerifyField<uint8_t>(verifier, VT_PERSISTABLE) &&
           VerifyField<uint8_t>(verifier, VT_NEED_CHECK_FEED) &&
           verifier.EndTable();
  }
  VarDescT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VarDescT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<VarDesc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarDescT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VarDescBuilder {
  typedef VarDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(VarDesc::VT_NAME, name);
  }
  void add_type(flatbuffers::Offset<paddle::lite::fbs::proto::VarType> type) {
    fbb_.AddOffset(VarDesc::VT_TYPE, type);
  }
  void add_persistable(bool persistable) {
    fbb_.AddElement<uint8_t>(VarDesc::VT_PERSISTABLE, static_cast<uint8_t>(persistable), 0);
  }
  void add_need_check_feed(bool need_check_feed) {
    fbb_.AddElement<uint8_t>(VarDesc::VT_NEED_CHECK_FEED, static_cast<uint8_t>(need_check_feed), 0);
  }
  explicit VarDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VarDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VarDesc>(end);
    fbb_.Required(o, VarDesc::VT_NAME);
    fbb_.Required(o, VarDesc::VT_TYPE);
    return o;
  }
};

inline flatbuffers::Offset<VarDesc> CreateVarDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<paddle::lite::fbs::proto::VarType> type = 0,
    bool persistable = false,
    bool need_check_feed = false) {
  VarDescBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_need_check_feed(need_check_feed);
  builder_.add_persistable(persistable);
  return builder_.Finish();
}

inline flatbuffers::Offset<VarDesc> CreateVarDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<paddle::lite::fbs::proto::VarType> type = 0,
    bool persistable = false,
    bool need_check_feed = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return paddle::lite::fbs::proto::CreateVarDesc(
      _fbb,
      name__,
      type,
      persistable,
      need_check_feed);
}

flatbuffers::Offset<VarDesc> CreateVarDesc(flatbuffers::FlatBufferBuilder &_fbb, const VarDescT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BlockDescT : public flatbuffers::NativeTable {
  typedef BlockDesc TableType;
  int32_t idx;
  int32_t parent_idx;
  std::vector<std::unique_ptr<paddle::lite::fbs::proto::VarDescT>> vars;
  std::vector<std::unique_ptr<paddle::lite::fbs::proto::OpDescT>> ops;
  int32_t forward_block_idx;
  BlockDescT()
      : idx(0),
        parent_idx(0),
        forward_block_idx(-1) {
  }
};

struct BlockDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BlockDescT NativeTableType;
  typedef BlockDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDX = 4,
    VT_PARENT_IDX = 6,
    VT_VARS = 8,
    VT_OPS = 10,
    VT_FORWARD_BLOCK_IDX = 12
  };
  int32_t idx() const {
    return GetField<int32_t>(VT_IDX, 0);
  }
  int32_t parent_idx() const {
    return GetField<int32_t>(VT_PARENT_IDX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarDesc>> *vars() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarDesc>> *>(VT_VARS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc>> *ops() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc>> *>(VT_OPS);
  }
  int32_t forward_block_idx() const {
    return GetField<int32_t>(VT_FORWARD_BLOCK_IDX, -1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_IDX) &&
           VerifyField<int32_t>(verifier, VT_PARENT_IDX) &&
           VerifyOffset(verifier, VT_VARS) &&
           verifier.VerifyVector(vars()) &&
           verifier.VerifyVectorOfTables(vars()) &&
           VerifyOffset(verifier, VT_OPS) &&
           verifier.VerifyVector(ops()) &&
           verifier.VerifyVectorOfTables(ops()) &&
           VerifyField<int32_t>(verifier, VT_FORWARD_BLOCK_IDX) &&
           verifier.EndTable();
  }
  BlockDescT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BlockDescT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BlockDesc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlockDescT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BlockDescBuilder {
  typedef BlockDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_idx(int32_t idx) {
    fbb_.AddElement<int32_t>(BlockDesc::VT_IDX, idx, 0);
  }
  void add_parent_idx(int32_t parent_idx) {
    fbb_.AddElement<int32_t>(BlockDesc::VT_PARENT_IDX, parent_idx, 0);
  }
  void add_vars(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarDesc>>> vars) {
    fbb_.AddOffset(BlockDesc::VT_VARS, vars);
  }
  void add_ops(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc>>> ops) {
    fbb_.AddOffset(BlockDesc::VT_OPS, ops);
  }
  void add_forward_block_idx(int32_t forward_block_idx) {
    fbb_.AddElement<int32_t>(BlockDesc::VT_FORWARD_BLOCK_IDX, forward_block_idx, -1);
  }
  explicit BlockDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BlockDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlockDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlockDesc> CreateBlockDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t idx = 0,
    int32_t parent_idx = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarDesc>>> vars = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc>>> ops = 0,
    int32_t forward_block_idx = -1) {
  BlockDescBuilder builder_(_fbb);
  builder_.add_forward_block_idx(forward_block_idx);
  builder_.add_ops(ops);
  builder_.add_vars(vars);
  builder_.add_parent_idx(parent_idx);
  builder_.add_idx(idx);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlockDesc> CreateBlockDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t idx = 0,
    int32_t parent_idx = 0,
    std::vector<flatbuffers::Offset<paddle::lite::fbs::proto::VarDesc>> *vars = nullptr,
    const std::vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc>> *ops = nullptr,
    int32_t forward_block_idx = -1) {
  auto vars__ = vars ? _fbb.CreateVectorOfSortedTables<paddle::lite::fbs::proto::VarDesc>(vars) : 0;
  auto ops__ = ops ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc>>(*ops) : 0;
  return paddle::lite::fbs::proto::CreateBlockDesc(
      _fbb,
      idx,
      parent_idx,
      vars__,
      ops__,
      forward_block_idx);
}

flatbuffers::Offset<BlockDesc> CreateBlockDesc(flatbuffers::FlatBufferBuilder &_fbb, const BlockDescT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CompatibleInfoT : public flatbuffers::NativeTable {
  typedef CompatibleInfo TableType;
  std::string version;
  paddle::lite::fbs::proto::CompatibleInfo_::Type type;
  CompatibleInfoT()
      : type(paddle::lite::fbs::proto::CompatibleInfo_::Type_COMPATIBLE) {
  }
};

struct CompatibleInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CompatibleInfoT NativeTableType;
  typedef CompatibleInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_TYPE = 6
  };
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  paddle::lite::fbs::proto::CompatibleInfo_::Type type() const {
    return static_cast<paddle::lite::fbs::proto::CompatibleInfo_::Type>(GetField<int32_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
  CompatibleInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CompatibleInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CompatibleInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CompatibleInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CompatibleInfoBuilder {
  typedef CompatibleInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(CompatibleInfo::VT_VERSION, version);
  }
  void add_type(paddle::lite::fbs::proto::CompatibleInfo_::Type type) {
    fbb_.AddElement<int32_t>(CompatibleInfo::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  explicit CompatibleInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CompatibleInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompatibleInfo>(end);
    fbb_.Required(o, CompatibleInfo::VT_VERSION);
    return o;
  }
};

inline flatbuffers::Offset<CompatibleInfo> CreateCompatibleInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    paddle::lite::fbs::proto::CompatibleInfo_::Type type = paddle::lite::fbs::proto::CompatibleInfo_::Type_COMPATIBLE) {
  CompatibleInfoBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompatibleInfo> CreateCompatibleInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    paddle::lite::fbs::proto::CompatibleInfo_::Type type = paddle::lite::fbs::proto::CompatibleInfo_::Type_COMPATIBLE) {
  auto version__ = version ? _fbb.CreateString(version) : 0;
  return paddle::lite::fbs::proto::CreateCompatibleInfo(
      _fbb,
      version__,
      type);
}

flatbuffers::Offset<CompatibleInfo> CreateCompatibleInfo(flatbuffers::FlatBufferBuilder &_fbb, const CompatibleInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OpCompatibleMapT : public flatbuffers::NativeTable {
  typedef OpCompatibleMap TableType;
  std::vector<std::unique_ptr<paddle::lite::fbs::proto::OpCompatibleMap_::OpCompatiblePairT>> pair;
  std::string default_required_version;
  OpCompatibleMapT() {
  }
};

struct OpCompatibleMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpCompatibleMapT NativeTableType;
  typedef OpCompatibleMapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAIR = 4,
    VT_DEFAULT_REQUIRED_VERSION = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpCompatibleMap_::OpCompatiblePair>> *pair() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpCompatibleMap_::OpCompatiblePair>> *>(VT_PAIR);
  }
  const flatbuffers::String *default_required_version() const {
    return GetPointer<const flatbuffers::String *>(VT_DEFAULT_REQUIRED_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAIR) &&
           verifier.VerifyVector(pair()) &&
           verifier.VerifyVectorOfTables(pair()) &&
           VerifyOffset(verifier, VT_DEFAULT_REQUIRED_VERSION) &&
           verifier.VerifyString(default_required_version()) &&
           verifier.EndTable();
  }
  OpCompatibleMapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OpCompatibleMapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OpCompatibleMap> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpCompatibleMapT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OpCompatibleMapBuilder {
  typedef OpCompatibleMap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pair(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpCompatibleMap_::OpCompatiblePair>>> pair) {
    fbb_.AddOffset(OpCompatibleMap::VT_PAIR, pair);
  }
  void add_default_required_version(flatbuffers::Offset<flatbuffers::String> default_required_version) {
    fbb_.AddOffset(OpCompatibleMap::VT_DEFAULT_REQUIRED_VERSION, default_required_version);
  }
  explicit OpCompatibleMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OpCompatibleMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpCompatibleMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<OpCompatibleMap> CreateOpCompatibleMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpCompatibleMap_::OpCompatiblePair>>> pair = 0,
    flatbuffers::Offset<flatbuffers::String> default_required_version = 0) {
  OpCompatibleMapBuilder builder_(_fbb);
  builder_.add_default_required_version(default_required_version);
  builder_.add_pair(pair);
  return builder_.Finish();
}

inline flatbuffers::Offset<OpCompatibleMap> CreateOpCompatibleMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<flatbuffers::Offset<paddle::lite::fbs::proto::OpCompatibleMap_::OpCompatiblePair>> *pair = nullptr,
    const char *default_required_version = nullptr) {
  auto pair__ = pair ? _fbb.CreateVectorOfSortedTables<paddle::lite::fbs::proto::OpCompatibleMap_::OpCompatiblePair>(pair) : 0;
  auto default_required_version__ = default_required_version ? _fbb.CreateString(default_required_version) : 0;
  return paddle::lite::fbs::proto::CreateOpCompatibleMap(
      _fbb,
      pair__,
      default_required_version__);
}

flatbuffers::Offset<OpCompatibleMap> CreateOpCompatibleMap(flatbuffers::FlatBufferBuilder &_fbb, const OpCompatibleMapT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace OpCompatibleMap_ {

struct OpCompatiblePairT : public flatbuffers::NativeTable {
  typedef OpCompatiblePair TableType;
  std::string op_name;
  std::unique_ptr<paddle::lite::fbs::proto::CompatibleInfoT> compatible_info;
  OpCompatiblePairT() {
  }
};

struct OpCompatiblePair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpCompatiblePairT NativeTableType;
  typedef OpCompatiblePairBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_NAME = 4,
    VT_COMPATIBLE_INFO = 6
  };
  const flatbuffers::String *op_name() const {
    return GetPointer<const flatbuffers::String *>(VT_OP_NAME);
  }
  bool KeyCompareLessThan(const OpCompatiblePair *o) const {
    return *op_name() < *o->op_name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(op_name()->c_str(), val);
  }
  const paddle::lite::fbs::proto::CompatibleInfo *compatible_info() const {
    return GetPointer<const paddle::lite::fbs::proto::CompatibleInfo *>(VT_COMPATIBLE_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_OP_NAME) &&
           verifier.VerifyString(op_name()) &&
           VerifyOffsetRequired(verifier, VT_COMPATIBLE_INFO) &&
           verifier.VerifyTable(compatible_info()) &&
           verifier.EndTable();
  }
  OpCompatiblePairT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OpCompatiblePairT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OpCompatiblePair> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpCompatiblePairT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OpCompatiblePairBuilder {
  typedef OpCompatiblePair Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_op_name(flatbuffers::Offset<flatbuffers::String> op_name) {
    fbb_.AddOffset(OpCompatiblePair::VT_OP_NAME, op_name);
  }
  void add_compatible_info(flatbuffers::Offset<paddle::lite::fbs::proto::CompatibleInfo> compatible_info) {
    fbb_.AddOffset(OpCompatiblePair::VT_COMPATIBLE_INFO, compatible_info);
  }
  explicit OpCompatiblePairBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OpCompatiblePair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpCompatiblePair>(end);
    fbb_.Required(o, OpCompatiblePair::VT_OP_NAME);
    fbb_.Required(o, OpCompatiblePair::VT_COMPATIBLE_INFO);
    return o;
  }
};

inline flatbuffers::Offset<OpCompatiblePair> CreateOpCompatiblePair(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> op_name = 0,
    flatbuffers::Offset<paddle::lite::fbs::proto::CompatibleInfo> compatible_info = 0) {
  OpCompatiblePairBuilder builder_(_fbb);
  builder_.add_compatible_info(compatible_info);
  builder_.add_op_name(op_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<OpCompatiblePair> CreateOpCompatiblePairDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *op_name = nullptr,
    flatbuffers::Offset<paddle::lite::fbs::proto::CompatibleInfo> compatible_info = 0) {
  auto op_name__ = op_name ? _fbb.CreateString(op_name) : 0;
  return paddle::lite::fbs::proto::OpCompatibleMap_::CreateOpCompatiblePair(
      _fbb,
      op_name__,
      compatible_info);
}

flatbuffers::Offset<OpCompatiblePair> CreateOpCompatiblePair(flatbuffers::FlatBufferBuilder &_fbb, const OpCompatiblePairT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace OpCompatibleMap_

struct ProgramDescT : public flatbuffers::NativeTable {
  typedef ProgramDesc TableType;
  std::vector<std::unique_ptr<paddle::lite::fbs::proto::BlockDescT>> blocks;
  std::unique_ptr<paddle::lite::fbs::proto::VersionT> version;
  std::unique_ptr<paddle::lite::fbs::proto::OpCompatibleMapT> op_compatible_map;
  ProgramDescT() {
  }
};

struct ProgramDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProgramDescT NativeTableType;
  typedef ProgramDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKS = 4,
    VT_VERSION = 6,
    VT_OP_COMPATIBLE_MAP = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::BlockDesc>> *blocks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::BlockDesc>> *>(VT_BLOCKS);
  }
  const paddle::lite::fbs::proto::Version *version() const {
    return GetPointer<const paddle::lite::fbs::proto::Version *>(VT_VERSION);
  }
  const paddle::lite::fbs::proto::OpCompatibleMap *op_compatible_map() const {
    return GetPointer<const paddle::lite::fbs::proto::OpCompatibleMap *>(VT_OP_COMPATIBLE_MAP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCKS) &&
           verifier.VerifyVector(blocks()) &&
           verifier.VerifyVectorOfTables(blocks()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyTable(version()) &&
           VerifyOffset(verifier, VT_OP_COMPATIBLE_MAP) &&
           verifier.VerifyTable(op_compatible_map()) &&
           verifier.EndTable();
  }
  ProgramDescT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProgramDescT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProgramDesc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProgramDescT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProgramDescBuilder {
  typedef ProgramDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blocks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::BlockDesc>>> blocks) {
    fbb_.AddOffset(ProgramDesc::VT_BLOCKS, blocks);
  }
  void add_version(flatbuffers::Offset<paddle::lite::fbs::proto::Version> version) {
    fbb_.AddOffset(ProgramDesc::VT_VERSION, version);
  }
  void add_op_compatible_map(flatbuffers::Offset<paddle::lite::fbs::proto::OpCompatibleMap> op_compatible_map) {
    fbb_.AddOffset(ProgramDesc::VT_OP_COMPATIBLE_MAP, op_compatible_map);
  }
  explicit ProgramDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProgramDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProgramDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProgramDesc> CreateProgramDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<paddle::lite::fbs::proto::BlockDesc>>> blocks = 0,
    flatbuffers::Offset<paddle::lite::fbs::proto::Version> version = 0,
    flatbuffers::Offset<paddle::lite::fbs::proto::OpCompatibleMap> op_compatible_map = 0) {
  ProgramDescBuilder builder_(_fbb);
  builder_.add_op_compatible_map(op_compatible_map);
  builder_.add_version(version);
  builder_.add_blocks(blocks);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProgramDesc> CreateProgramDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<paddle::lite::fbs::proto::BlockDesc>> *blocks = nullptr,
    flatbuffers::Offset<paddle::lite::fbs::proto::Version> version = 0,
    flatbuffers::Offset<paddle::lite::fbs::proto::OpCompatibleMap> op_compatible_map = 0) {
  auto blocks__ = blocks ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::BlockDesc>>(*blocks) : 0;
  return paddle::lite::fbs::proto::CreateProgramDesc(
      _fbb,
      blocks__,
      version,
      op_compatible_map);
}

flatbuffers::Offset<ProgramDesc> CreateProgramDesc(flatbuffers::FlatBufferBuilder &_fbb, const ProgramDescT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline VersionT *Version::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::VersionT> _o = std::unique_ptr<paddle::lite::fbs::proto::VersionT>(new VersionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Version::UnPackTo(VersionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); _o->version = _e; }
}

inline flatbuffers::Offset<Version> Version::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VersionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVersion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Version> CreateVersion(flatbuffers::FlatBufferBuilder &_fbb, const VersionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VersionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _o->version;
  return paddle::lite::fbs::proto::CreateVersion(
      _fbb,
      _version);
}

inline OpDescT *OpDesc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::OpDescT> _o = std::unique_ptr<paddle::lite::fbs::proto::OpDescT>(new OpDescT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OpDesc::UnPackTo(OpDescT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); }
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::VarT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::VarT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = attrs(); if (_e) { _o->attrs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attrs[_i] = std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::AttrT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = is_target(); _o->is_target = _e; }
}

inline flatbuffers::Offset<OpDesc> OpDesc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpDescT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOpDesc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OpDesc> CreateOpDesc(flatbuffers::FlatBufferBuilder &_fbb, const OpDescT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OpDescT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _fbb.CreateString(_o->type);
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> (_o->inputs.size(), [](size_t i, _VectorArgs *__va) { return CreateVar(*__va->__fbb, __va->__o->inputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Var>> (_o->outputs.size(), [](size_t i, _VectorArgs *__va) { return CreateVar(*__va->__fbb, __va->__o->outputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _attrs = _o->attrs.size() ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc_::Attr>> (_o->attrs.size(), [](size_t i, _VectorArgs *__va) { return CreateAttr(*__va->__fbb, __va->__o->attrs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _is_target = _o->is_target;
  return paddle::lite::fbs::proto::CreateOpDesc(
      _fbb,
      _type,
      _inputs,
      _outputs,
      _attrs,
      _is_target);
}

namespace OpDesc_ {

inline AttrT *Attr::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::AttrT> _o = std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::AttrT>(new AttrT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Attr::UnPackTo(AttrT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = type(); _o->type = _e; }
  { auto _e = i(); _o->i = _e; }
  { auto _e = f(); _o->f = _e; }
  { auto _e = s(); if (_e) _o->s = _e->str(); }
  { auto _e = ints(); if (_e) { _o->ints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ints[_i] = _e->Get(_i); } } }
  { auto _e = floats(); if (_e) { _o->floats.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->floats[_i] = _e->Get(_i); } } }
  { auto _e = strings(); if (_e) { _o->strings.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strings[_i] = _e->Get(_i)->str(); } } }
  { auto _e = b(); _o->b = _e; }
  { auto _e = bools(); if (_e) { _o->bools.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bools[_i] = _e->Get(_i) != 0; } } }
  { auto _e = block_idx(); _o->block_idx = _e; }
  { auto _e = l(); _o->l = _e; }
  { auto _e = blocks_idx(); if (_e) { _o->blocks_idx.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->blocks_idx[_i] = _e->Get(_i); } } }
  { auto _e = longs(); if (_e) { _o->longs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->longs[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Attr> Attr::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttrT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAttr(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Attr> CreateAttr(flatbuffers::FlatBufferBuilder &_fbb, const AttrT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AttrT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _fbb.CreateString(_o->name);
  auto _type = _o->type;
  auto _i = _o->i;
  auto _f = _o->f;
  auto _s = _o->s.empty() ? 0 : _fbb.CreateString(_o->s);
  auto _ints = _o->ints.size() ? _fbb.CreateVector(_o->ints) : 0;
  auto _floats = _o->floats.size() ? _fbb.CreateVector(_o->floats) : 0;
  auto _strings = _o->strings.size() ? _fbb.CreateVectorOfStrings(_o->strings) : 0;
  auto _b = _o->b;
  auto _bools = _o->bools.size() ? _fbb.CreateVector(_o->bools) : 0;
  auto _block_idx = _o->block_idx;
  auto _l = _o->l;
  auto _blocks_idx = _o->blocks_idx.size() ? _fbb.CreateVector(_o->blocks_idx) : 0;
  auto _longs = _o->longs.size() ? _fbb.CreateVector(_o->longs) : 0;
  return paddle::lite::fbs::proto::OpDesc_::CreateAttr(
      _fbb,
      _name,
      _type,
      _i,
      _f,
      _s,
      _ints,
      _floats,
      _strings,
      _b,
      _bools,
      _block_idx,
      _l,
      _blocks_idx,
      _longs);
}

inline VarT *Var::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::VarT> _o = std::unique_ptr<paddle::lite::fbs::proto::OpDesc_::VarT>(new VarT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Var::UnPackTo(VarT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = parameter(); if (_e) _o->parameter = _e->str(); }
  { auto _e = arguments(); if (_e) { _o->arguments.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->arguments[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<Var> Var::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVar(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Var> CreateVar(flatbuffers::FlatBufferBuilder &_fbb, const VarT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VarT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _parameter = _fbb.CreateString(_o->parameter);
  auto _arguments = _o->arguments.size() ? _fbb.CreateVectorOfStrings(_o->arguments) : 0;
  return paddle::lite::fbs::proto::OpDesc_::CreateVar(
      _fbb,
      _parameter,
      _arguments);
}

}  // namespace OpDesc_

inline VarTypeT *VarType::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::VarTypeT> _o = std::unique_ptr<paddle::lite::fbs::proto::VarTypeT>(new VarTypeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VarType::UnPackTo(VarTypeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = selected_rows(); if (_e) _o->selected_rows = std::unique_ptr<paddle::lite::fbs::proto::VarType_::TensorDescT>(_e->UnPack(_resolver)); }
  { auto _e = lod_tensor(); if (_e) _o->lod_tensor = std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorDescT>(_e->UnPack(_resolver)); }
  { auto _e = tensor_array(); if (_e) _o->tensor_array = std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorArrayDescT>(_e->UnPack(_resolver)); }
  { auto _e = reader(); if (_e) _o->reader = std::unique_ptr<paddle::lite::fbs::proto::VarType_::ReaderDescT>(_e->UnPack(_resolver)); }
  { auto _e = tuple(); if (_e) _o->tuple = std::unique_ptr<paddle::lite::fbs::proto::VarType_::TupleT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<VarType> VarType::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarTypeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVarType(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VarType> CreateVarType(flatbuffers::FlatBufferBuilder &_fbb, const VarTypeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VarTypeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _selected_rows = _o->selected_rows ? CreateTensorDesc(_fbb, _o->selected_rows.get(), _rehasher) : 0;
  auto _lod_tensor = _o->lod_tensor ? CreateLoDTensorDesc(_fbb, _o->lod_tensor.get(), _rehasher) : 0;
  auto _tensor_array = _o->tensor_array ? CreateLoDTensorArrayDesc(_fbb, _o->tensor_array.get(), _rehasher) : 0;
  auto _reader = _o->reader ? CreateReaderDesc(_fbb, _o->reader.get(), _rehasher) : 0;
  auto _tuple = _o->tuple ? CreateTuple(_fbb, _o->tuple.get(), _rehasher) : 0;
  return paddle::lite::fbs::proto::CreateVarType(
      _fbb,
      _type,
      _selected_rows,
      _lod_tensor,
      _tensor_array,
      _reader,
      _tuple);
}

namespace VarType_ {

inline TensorDescT *TensorDesc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::TensorDescT> _o = std::unique_ptr<paddle::lite::fbs::proto::VarType_::TensorDescT>(new TensorDescT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorDesc::UnPackTo(TensorDescT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data_type(); _o->data_type = _e; }
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<TensorDesc> TensorDesc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorDesc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorDesc> CreateTensorDesc(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorDescT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data_type = _o->data_type;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  return paddle::lite::fbs::proto::VarType_::CreateTensorDesc(
      _fbb,
      _data_type,
      _dims);
}

inline LoDTensorDescT *LoDTensorDesc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorDescT> _o = std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorDescT>(new LoDTensorDescT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LoDTensorDesc::UnPackTo(LoDTensorDescT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tensor(); if (_e) _o->tensor = std::unique_ptr<paddle::lite::fbs::proto::VarType_::TensorDescT>(_e->UnPack(_resolver)); }
  { auto _e = lod_level(); _o->lod_level = _e; }
}

inline flatbuffers::Offset<LoDTensorDesc> LoDTensorDesc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoDTensorDescT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoDTensorDesc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LoDTensorDesc> CreateLoDTensorDesc(flatbuffers::FlatBufferBuilder &_fbb, const LoDTensorDescT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LoDTensorDescT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tensor = _o->tensor ? CreateTensorDesc(_fbb, _o->tensor.get(), _rehasher) : 0;
  auto _lod_level = _o->lod_level;
  return paddle::lite::fbs::proto::VarType_::CreateLoDTensorDesc(
      _fbb,
      _tensor,
      _lod_level);
}

inline LoDTensorArrayDescT *LoDTensorArrayDesc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorArrayDescT> _o = std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorArrayDescT>(new LoDTensorArrayDescT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LoDTensorArrayDesc::UnPackTo(LoDTensorArrayDescT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tensor(); if (_e) _o->tensor = std::unique_ptr<paddle::lite::fbs::proto::VarType_::TensorDescT>(_e->UnPack(_resolver)); }
  { auto _e = lod_level(); _o->lod_level = _e; }
}

inline flatbuffers::Offset<LoDTensorArrayDesc> LoDTensorArrayDesc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoDTensorArrayDescT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoDTensorArrayDesc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LoDTensorArrayDesc> CreateLoDTensorArrayDesc(flatbuffers::FlatBufferBuilder &_fbb, const LoDTensorArrayDescT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LoDTensorArrayDescT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tensor = _o->tensor ? CreateTensorDesc(_fbb, _o->tensor.get(), _rehasher) : 0;
  auto _lod_level = _o->lod_level;
  return paddle::lite::fbs::proto::VarType_::CreateLoDTensorArrayDesc(
      _fbb,
      _tensor,
      _lod_level);
}

inline ReaderDescT *ReaderDesc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::ReaderDescT> _o = std::unique_ptr<paddle::lite::fbs::proto::VarType_::ReaderDescT>(new ReaderDescT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReaderDesc::UnPackTo(ReaderDescT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = lod_tensor(); if (_e) { _o->lod_tensor.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lod_tensor[_i] = std::unique_ptr<paddle::lite::fbs::proto::VarType_::LoDTensorDescT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<ReaderDesc> ReaderDesc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReaderDescT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReaderDesc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReaderDesc> CreateReaderDesc(flatbuffers::FlatBufferBuilder &_fbb, const ReaderDescT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReaderDescT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _lod_tensor = _o->lod_tensor.size() ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::VarType_::LoDTensorDesc>> (_o->lod_tensor.size(), [](size_t i, _VectorArgs *__va) { return CreateLoDTensorDesc(*__va->__fbb, __va->__o->lod_tensor[i].get(), __va->__rehasher); }, &_va ) : 0;
  return paddle::lite::fbs::proto::VarType_::CreateReaderDesc(
      _fbb,
      _lod_tensor);
}

inline TupleT *Tuple::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::VarType_::TupleT> _o = std::unique_ptr<paddle::lite::fbs::proto::VarType_::TupleT>(new TupleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Tuple::UnPackTo(TupleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = element_type(); if (_e) { _o->element_type.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->element_type[_i] = static_cast<paddle::lite::fbs::proto::VarType_::Type>(_e->Get(_i)); } } }
}

inline flatbuffers::Offset<Tuple> Tuple::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TupleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTuple(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Tuple> CreateTuple(flatbuffers::FlatBufferBuilder &_fbb, const TupleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TupleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _element_type = _o->element_type.size() ? _fbb.CreateVectorScalarCast<int32_t>(flatbuffers::data(_o->element_type), _o->element_type.size()) : 0;
  return paddle::lite::fbs::proto::VarType_::CreateTuple(
      _fbb,
      _element_type);
}

}  // namespace VarType_

inline VarDescT *VarDesc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::VarDescT> _o = std::unique_ptr<paddle::lite::fbs::proto::VarDescT>(new VarDescT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VarDesc::UnPackTo(VarDescT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = type(); if (_e) _o->type = std::unique_ptr<paddle::lite::fbs::proto::VarTypeT>(_e->UnPack(_resolver)); }
  { auto _e = persistable(); _o->persistable = _e; }
  { auto _e = need_check_feed(); _o->need_check_feed = _e; }
}

inline flatbuffers::Offset<VarDesc> VarDesc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VarDescT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVarDesc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VarDesc> CreateVarDesc(flatbuffers::FlatBufferBuilder &_fbb, const VarDescT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VarDescT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _fbb.CreateString(_o->name);
  auto _type = _o->type ? CreateVarType(_fbb, _o->type.get(), _rehasher) : 0;
  auto _persistable = _o->persistable;
  auto _need_check_feed = _o->need_check_feed;
  return paddle::lite::fbs::proto::CreateVarDesc(
      _fbb,
      _name,
      _type,
      _persistable,
      _need_check_feed);
}

inline BlockDescT *BlockDesc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::BlockDescT> _o = std::unique_ptr<paddle::lite::fbs::proto::BlockDescT>(new BlockDescT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BlockDesc::UnPackTo(BlockDescT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = idx(); _o->idx = _e; }
  { auto _e = parent_idx(); _o->parent_idx = _e; }
  { auto _e = vars(); if (_e) { _o->vars.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vars[_i] = std::unique_ptr<paddle::lite::fbs::proto::VarDescT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = ops(); if (_e) { _o->ops.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ops[_i] = std::unique_ptr<paddle::lite::fbs::proto::OpDescT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = forward_block_idx(); _o->forward_block_idx = _e; }
}

inline flatbuffers::Offset<BlockDesc> BlockDesc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlockDescT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBlockDesc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BlockDesc> CreateBlockDesc(flatbuffers::FlatBufferBuilder &_fbb, const BlockDescT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BlockDescT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _idx = _o->idx;
  auto _parent_idx = _o->parent_idx;
  auto _vars = _o->vars.size() ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::VarDesc>> (_o->vars.size(), [](size_t i, _VectorArgs *__va) { return CreateVarDesc(*__va->__fbb, __va->__o->vars[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _ops = _o->ops.size() ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::OpDesc>> (_o->ops.size(), [](size_t i, _VectorArgs *__va) { return CreateOpDesc(*__va->__fbb, __va->__o->ops[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _forward_block_idx = _o->forward_block_idx;
  return paddle::lite::fbs::proto::CreateBlockDesc(
      _fbb,
      _idx,
      _parent_idx,
      _vars,
      _ops,
      _forward_block_idx);
}

inline CompatibleInfoT *CompatibleInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::CompatibleInfoT> _o = std::unique_ptr<paddle::lite::fbs::proto::CompatibleInfoT>(new CompatibleInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CompatibleInfo::UnPackTo(CompatibleInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); if (_e) _o->version = _e->str(); }
  { auto _e = type(); _o->type = _e; }
}

inline flatbuffers::Offset<CompatibleInfo> CompatibleInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CompatibleInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCompatibleInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CompatibleInfo> CreateCompatibleInfo(flatbuffers::FlatBufferBuilder &_fbb, const CompatibleInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CompatibleInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _fbb.CreateString(_o->version);
  auto _type = _o->type;
  return paddle::lite::fbs::proto::CreateCompatibleInfo(
      _fbb,
      _version,
      _type);
}

inline OpCompatibleMapT *OpCompatibleMap::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::OpCompatibleMapT> _o = std::unique_ptr<paddle::lite::fbs::proto::OpCompatibleMapT>(new OpCompatibleMapT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OpCompatibleMap::UnPackTo(OpCompatibleMapT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pair(); if (_e) { _o->pair.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pair[_i] = std::unique_ptr<paddle::lite::fbs::proto::OpCompatibleMap_::OpCompatiblePairT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = default_required_version(); if (_e) _o->default_required_version = _e->str(); }
}

inline flatbuffers::Offset<OpCompatibleMap> OpCompatibleMap::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpCompatibleMapT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOpCompatibleMap(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OpCompatibleMap> CreateOpCompatibleMap(flatbuffers::FlatBufferBuilder &_fbb, const OpCompatibleMapT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OpCompatibleMapT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pair = _o->pair.size() ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::OpCompatibleMap_::OpCompatiblePair>> (_o->pair.size(), [](size_t i, _VectorArgs *__va) { return CreateOpCompatiblePair(*__va->__fbb, __va->__o->pair[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _default_required_version = _o->default_required_version.empty() ? 0 : _fbb.CreateString(_o->default_required_version);
  return paddle::lite::fbs::proto::CreateOpCompatibleMap(
      _fbb,
      _pair,
      _default_required_version);
}

namespace OpCompatibleMap_ {

inline OpCompatiblePairT *OpCompatiblePair::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::OpCompatibleMap_::OpCompatiblePairT> _o = std::unique_ptr<paddle::lite::fbs::proto::OpCompatibleMap_::OpCompatiblePairT>(new OpCompatiblePairT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OpCompatiblePair::UnPackTo(OpCompatiblePairT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = op_name(); if (_e) _o->op_name = _e->str(); }
  { auto _e = compatible_info(); if (_e) _o->compatible_info = std::unique_ptr<paddle::lite::fbs::proto::CompatibleInfoT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<OpCompatiblePair> OpCompatiblePair::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpCompatiblePairT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOpCompatiblePair(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OpCompatiblePair> CreateOpCompatiblePair(flatbuffers::FlatBufferBuilder &_fbb, const OpCompatiblePairT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OpCompatiblePairT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _op_name = _fbb.CreateString(_o->op_name);
  auto _compatible_info = _o->compatible_info ? CreateCompatibleInfo(_fbb, _o->compatible_info.get(), _rehasher) : 0;
  return paddle::lite::fbs::proto::OpCompatibleMap_::CreateOpCompatiblePair(
      _fbb,
      _op_name,
      _compatible_info);
}

}  // namespace OpCompatibleMap_

inline ProgramDescT *ProgramDesc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<paddle::lite::fbs::proto::ProgramDescT> _o = std::unique_ptr<paddle::lite::fbs::proto::ProgramDescT>(new ProgramDescT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ProgramDesc::UnPackTo(ProgramDescT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = blocks(); if (_e) { _o->blocks.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->blocks[_i] = std::unique_ptr<paddle::lite::fbs::proto::BlockDescT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = version(); if (_e) _o->version = std::unique_ptr<paddle::lite::fbs::proto::VersionT>(_e->UnPack(_resolver)); }
  { auto _e = op_compatible_map(); if (_e) _o->op_compatible_map = std::unique_ptr<paddle::lite::fbs::proto::OpCompatibleMapT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<ProgramDesc> ProgramDesc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProgramDescT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProgramDesc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProgramDesc> CreateProgramDesc(flatbuffers::FlatBufferBuilder &_fbb, const ProgramDescT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProgramDescT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _blocks = _o->blocks.size() ? _fbb.CreateVector<flatbuffers::Offset<paddle::lite::fbs::proto::BlockDesc>> (_o->blocks.size(), [](size_t i, _VectorArgs *__va) { return CreateBlockDesc(*__va->__fbb, __va->__o->blocks[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _version = _o->version ? CreateVersion(_fbb, _o->version.get(), _rehasher) : 0;
  auto _op_compatible_map = _o->op_compatible_map ? CreateOpCompatibleMap(_fbb, _o->op_compatible_map.get(), _rehasher) : 0;
  return paddle::lite::fbs::proto::CreateProgramDesc(
      _fbb,
      _blocks,
      _version,
      _op_compatible_map);
}

inline const paddle::lite::fbs::proto::ProgramDesc *GetProgramDesc(const void *buf) {
  return flatbuffers::GetRoot<paddle::lite::fbs::proto::ProgramDesc>(buf);
}

inline const paddle::lite::fbs::proto::ProgramDesc *GetSizePrefixedProgramDesc(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<paddle::lite::fbs::proto::ProgramDesc>(buf);
}

inline bool VerifyProgramDescBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<paddle::lite::fbs::proto::ProgramDesc>(nullptr);
}

inline bool VerifySizePrefixedProgramDescBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<paddle::lite::fbs::proto::ProgramDesc>(nullptr);
}

inline void FinishProgramDescBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<paddle::lite::fbs::proto::ProgramDesc> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedProgramDescBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<paddle::lite::fbs::proto::ProgramDesc> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<paddle::lite::fbs::proto::ProgramDescT> UnPackProgramDesc(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<paddle::lite::fbs::proto::ProgramDescT>(GetProgramDesc(buf)->UnPack(res));
}

inline std::unique_ptr<paddle::lite::fbs::proto::ProgramDescT> UnPackSizePrefixedProgramDesc(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<paddle::lite::fbs::proto::ProgramDescT>(GetSizePrefixedProgramDesc(buf)->UnPack(res));
}

}  // namespace proto
}  // namespace fbs
}  // namespace lite
}  // namespace paddle

#endif  // FLATBUFFERS_GENERATED_FRAMEWORK_PADDLE_LITE_FBS_PROTO_H_
